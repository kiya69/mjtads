<!DOCTYPE html>
<html>
<head>
    <title>Taiwan Voronoi Treemap</title>
    <!-- Google Fonts - Noto Sans TC for Traditional Chinese support -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          crossorigin=""/>
    <style>
        body { 
            margin: 0; 
            overflow-x: hidden; 
            overflow-y: auto; 
            font-family: 'Noto Sans TC', sans-serif;
            background: #f5f5f5;
        }
        
        .headline {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, #16476a 0%, #3b9797 100%);
            color: white;
            font-size: 2.5rem;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            letter-spacing: 1px;
        }
        
        #treemap-container {
            position: relative; /* Needed for tooltip positioning */
            width: 100%;
            height: 85vh;
            min-height: 700px;
            margin: 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #map {
            width: 100%;
            height: 100%;
            z-index: 0; /* Ensure map is behind SVG overlay */
            min-height: 400px; /* Ensure map has minimum height */
            background-color: #e0e0e0; /* Temporary background to see if div exists */
        }
        
        /* Leaflet map container styles */
        .leaflet-container {
            background: #f0f0f0;
            height: 100% !important;
            width: 100% !important;
        }

        #treemap-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow map interaction to pass through */
            z-index: 50; /* Lower z-index so markers appear on top */
            background: transparent; /* Make sure it's transparent, not blocking */
        }

        #treemap-svg .cell {
            pointer-events: all; /* But allow interaction with cells */
        }

        .cell {
            stroke: #fff;
            stroke-width: 0.5px;
            cursor: pointer;
            transition: fill 0.2s;
        }

        .cell:hover {
            opacity: 0.8;
        }

        .country-label {
            font-size: 8px; /* Smaller for irregular shapes */
            /* fill color set dynamically in JavaScript */
            stroke: none; /* Remove any outline/border */
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
        }
        
        .country-label.taiwan-label {
            font-size: 14px; /* Larger font for Taiwan */
        }
        
        .country-label.taiwan-label tspan {
            font-size: 14px !important; /* Override inline styles for Taiwan */
        }

        /* For the Taiwan outline itself */
        .taiwan-outline {
            fill: none;
            stroke: #333;
            stroke-width: 1.5px;
            stroke-linejoin: round;
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 16px;
        }

        .tooltip-content {
            font-size: 13px;
            line-height: 1.6;
        }

        /* Floating info boxes */
        .info-box {
            position: absolute;
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 100;
            overflow: hidden;
            min-width: 200px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            border: 2px solid #e8e8e8;
        }
        
        .info-box-content {
            flex: 1;
            overflow-y: auto;
            padding: 25px;
            padding-top: 15px;
            background: #fafafa;
        }
        
        .info-box p {
            margin: 12px 0;
            color: #333;
            font-size: 14px;
            line-height: 1.7;
        }
        
        /* Resize handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            background: linear-gradient(-45deg, transparent 30%, #ccc 30%, #ccc 35%, transparent 35%, transparent 65%, #ccc 65%, #ccc 70%, transparent 70%);
            border-bottom-right-radius: 10px;
            z-index: 101;
        }
        
        .resize-handle:hover {
            background: linear-gradient(-45deg, transparent 30%, #999 30%, #999 35%, transparent 35%, transparent 65%, #999 65%, #999 70%, transparent 70%);
        }
        
        .info-box.resizing {
            user-select: none;
        }

        .info-box-large {
            width: 690px; /* 20% wider (300 * 1.2) */
            height: 662px;
            left: 0;
            top: 0; /* Center vertically without transform */
        }

        .info-box-medium {
            width: 600px;
            height: calc(47vh - 77px);
        }

        /* Section styling for B and C info boxes */
        .sections-container {
            width: 100%;
            max-width: 1400px;
            margin: 50px auto;
            padding: 0 40px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 40px;
        }
        
        .content-section {
            width: 100%;
        }
        
        .section-info-box {
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
            min-width: 200px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            height: 100%;
            border: 1px solid #e0e0e0;
            overflow: hidden;
        }
        
        .section-info-box h3 {
            margin: 0;
            color: white;
            font-size: 20px;
            background: linear-gradient(135deg, #16476a 0%, #3b9797 100%);
            padding: 25px 30px;
            user-select: none;
            position: relative;
            z-index: 1;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .section-info-box .info-box-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            padding-top: 20px;
            background: #fafafa;
        }
        
        .chart-image-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
            margin-top: 20px;
        }
        
        .chart-image-container img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .image-caption {
            margin-top: 8px;
            font-size: 11px;
            color: #666;
            font-style: italic;
            text-align: center;
        }
        
        .image-caption-top {
            margin-bottom: 10px;
            font-size: 12px;
            color: #555;
            font-weight: 500;
            text-align: center;
        }
        
        .chart-caption {
            margin-bottom: 15px;
            font-size: 13px;
            color: #555;
            font-weight: 500;
            text-align: center;
        }
        
        .image-caption a {
            color: #3b9797;
            text-decoration: none;
        }
        
        .image-caption a:hover {
            text-decoration: underline;
        }
        
        /* Modal for enlarged images */
        .image-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            cursor: pointer;
        }
        
        .image-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .image-modal-content {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .image-modal-close {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10001;
        }
        
        .image-modal-close:hover {
            color: #ccc;
        }
        
        .enlargeable-image {
            cursor: pointer;
            transition: opacity 0.3s;
        }
        
        .enlargeable-image:hover {
            opacity: 0.9;
        }
        
        .chart-image-container .military-chart {
            width: 100%;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        @media (max-width: 900px) {
            .chart-image-container {
                grid-template-columns: 1fr;
            }
        }
        
        #info-box-top {
            right: 20px;
            top: 20px;
        }

        #info-box-bottom {
            left: 20px;
            top: 20px;
        }

        .info-box h3 {
            margin: 0;
            color: white;
            font-size: 18px;
            background: linear-gradient(135deg, #16476a 0%, #3b9797 100%);
            padding: 20px 20px 15px 20px;
            cursor: move;
            user-select: none;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .info-box.dragging {
            opacity: 0.8;
            z-index: 200;
        }

        .info-box p {
            margin: 10px 0;
            color: #333;
            font-size: 14px;
            line-height: 1.6;
        }
        
        /* Explosion marker styling */
        .explosion-marker {
            background: transparent;
            border: none;
            font-size: 24px;
            text-align: center;
            line-height: 30px;
            cursor: pointer;
        }
        
        /* Explosion info floating boxes */
        .explosion-info-box {
            position: absolute;
            background: white;
            border-radius: 12px;
            padding: 15px 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 200;
            min-width: 280px;
            max-width: 350px;
            border: 2px solid #e8e8e8;
        }
        
        .explosion-info-box p {
            margin: 5px 0;
            color: #333;
            line-height: 1.6;
            font-size: 13px;
        }
        
        .explosion-info-box strong {
            color: #16476a;
        }
    </style>
</head>
<body>

<div class="headline">
    China's Attempts to Undermine Taiwan's Security
</div>

<div id="treemap-container">
    <div id="map"></div>
    <div id="tooltip" class="tooltip">
        <div class="tooltip-title"></div>
        <div class="tooltip-content"></div>
    </div>
    
    <div id="info-box-bottom" class="info-box info-box-medium">
        <h3>Did you know Chinese ships have cut Taiwan's global cables 30+ times since 2017.</h3>
        <div class="info-box-content">
            <p>â€¢ China has even invented a deep sea cable cutter for this purpose.</p>
            <img src="cable_cutter.jpeg" alt="Deep sea cable cutter" class="enlargeable-image" style="width: 100%; height: auto; margin-top: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" onclick="openImageModal(this.src)">
        </div>
        <div class="resize-handle"></div>
    </div>
    
    <!-- Explosion info floating boxes -->
    <div id="explosion-box-1" class="explosion-info-box" style="right: 20px; top: 100px;">
        <p><strong>ðŸ’¥1. Keelung Cable Cut</strong></p>
        <p><strong>Date:</strong> January 3, 2025</p>
        <p>A Tanzania-flagged vessel while registered in Cameroon called Shunxin-39, controlled by a Chinese entity, deliberately severed subsea cables near Keelung, disrupting Taiwan's external communications.</p>
    </div>
    
    <div id="explosion-box-2" class="explosion-info-box" style="right: 20px; top: 280px;">
        <p><strong>ðŸ’¥2. Taiwan-Penghu Cable Cut</strong></p>
        <p><strong>Date:</strong> February 25, 2025</p>
        <p>A Togolese-registered cargo vessel that severed a submarine communication cable between Taiwan and Penghu.</p>
    </div>
</div>

<!-- Section 1: Military Activities -->
<div class="sections-container">
    <section class="content-section">
        <div class="section-info-box">
            <h3>Did you know China's military has operated near Taiwan almost daily for the past five years?</h3>
            <div class="info-box-content">
                <p style="margin-bottom: 20px; color: #555; font-size: 13px; line-height: 1.6;">30 days activities gathered from Ministry of National Defense of Taiwan. Mapping all the aircrafts, drones, helicopters, naval ships.</p>
                <p style="margin-bottom: 20px; color: #8080c0; font-size: 13px; line-height: 1.6; font-weight: 600; padding: 12px; background: #f0f0f8; border-left: 4px solid #8080c0; border-radius: 4px;"><strong>Fun fact:</strong> The only day that they didn't send any aircrafts or ships to Taiwan strait is the day when there was a typhoon on 11/11/2025.</p>
                <div class="chart-image-container">
                    <div>
                        <p class="image-caption-top">Images gathered and mapped to see all the trajectories by PLA using Maximum Difference Projection</p>
                        <img src="military_map.png" alt="Military Map" style="width: 100%; height: auto; margin-top: 10px; border-radius: 5px;">
                        <p class="image-caption">Source: <a href="https://www.mnd.gov.tw/PublishTable.aspx?Types=%E5%8D%B3%E6%99%82%E8%BB%8D%E4%BA%8B%E5%8B%95%E6%85%8B&title=%E5%9C%8B%E9%98%B2%E6%B6%88%E6%81%AF" target="_blank">Ministry of National Defense, R.O.C.</a></p>
                    </div>
                    <div>
                        <p class="chart-caption">Trends of military activities categorized by aircrafts and vessals over the past 30 days</p>
                        <div class="military-chart"></div>
                    </div>
                </div>
            </div>
        </div>
    </section>
</div>

<!-- Section 2: Foreign Information Dissemination with Treemap -->
<div class="sections-container">
    <section class="content-section">
        <div class="section-info-box" style="min-height: 800px;">
            <h3>Did you know that Taiwan has been most influnce by China's dissemination of false information over 10 years?</h3>
            <div class="info-box-content">
                <p style="margin-bottom: 20px;">According <a href="https://digitalsocietyproject.org/data/" target="_blank">digital society project</a> Taiwan has been influnced for at least 11 years and ranked #1 in the world in the foreign governments dissemination of false information.</p>
                <div style="display: flex; gap: 20px; align-items: flex-start; margin: 20px 0;">
                    <div id="treemap-container-section2" style="position: relative; flex: 1; height: 600px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <div id="map-section2" style="width: 100%; height: 100%; z-index: 0; position: absolute; top: 0; left: 0; border-radius: 8px; margin: 0; padding: 0;"></div>
                        <svg id="treemap-svg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; background: transparent;"></svg>
                        <div id="tooltip" class="tooltip">
                            <div class="tooltip-title"></div>
                            <div class="tooltip-content"></div>
                        </div>
                    </div>
                    <div class="info-box-large" style="position: relative; flex: 1; height: 600px;">
                        <!-- Line chart will be inserted here -->
                    </div>
                </div>
                <div style="margin-top: 30px;">
                    <iframe title="Foreign governments dissemination of false information in 2024" aria-label="Choropleth map" id="datawrapper-chart-4zey2" src="https://datawrapper.dwcdn.net/4zey2/1/" scrolling="no" frameborder="0" style="width: 0; min-width: 100% !important; border: none;" height="578" data-external="1"></iframe>
                    <script type="text/javascript">window.addEventListener("message",function(a){if(void 0!==a.data["datawrapper-height"]){var e=document.querySelectorAll("iframe");for(var t in a.data["datawrapper-height"])for(var r,i=0;r=e[i];i++)if(r.contentWindow===a.source){var d=a.data["datawrapper-height"][t]+"px";r.style.height=d}}});</script>
                </div>
            </div>
        </div>
    </section>
</div>

<!-- Load JavaScript libraries before our script -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        crossorigin=""></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="d3-weighted-voronoi.min.js"></script>
<script src="d3-voronoi-map.min.js"></script>
<script src="d3-voronoi-treemap.min.js"></script>

<script>
    let map;
    let drawExplosionBoxLinesGlobal = null; // Global reference to the function
    
    const data = [
        { Country: 'Taiwan', Score: -3.845, Size: 3.845, Category: 'Red', Rank: 1 },
        { Country: 'Portugal', Score: 2.859, Size: 2.859, Category: 'Green', Rank: 179 },
        { Country: 'Belarus', Score: -3.326, Size: 3.326, Category: 'Red', Rank: 2 },
        { Country: 'Malawi', Score: 2.645, Size: 2.645, Category: 'Green', Rank: 178 },
        { Country: 'Latvia', Score: -3.276, Size: 3.276, Category: 'Red', Rank: 3 },
        { Country: 'Trinidad and Tobago', Score: 2.606, Size: 2.606, Category: 'Green', Rank: 177 },
        { Country: 'Syria', Score: -2.630, Size: 2.630, Category: 'Red', Rank: 4},
        { Country: 'Switzerland', Score: 2.434, Size: 2.434, Category: 'Green', Rank: 176 },
        { Country: 'Kosovo', Score: -2.612, Size: 2.612, Category: 'Red', Rank: 5 },
        { Country: 'Seychelles', Score: 2.402, Size: 2.402, Category: 'Green', Rank: 175 }
    ];
    // CSV data for line chart
    const csvData = `country_name,year,v2smfordom
Switzerland,2015,2.434
Switzerland,2016,2.434
Switzerland,2017,2.434
Switzerland,2018,2.434
Switzerland,2019,2.434
Switzerland,2020,2.434
Switzerland,2021,2.434
Switzerland,2022,2.434
Switzerland,2023,2.434
Switzerland,2024,2.434
Portugal,2015,3.033
Portugal,2016,3.033
Portugal,2017,3.033
Portugal,2018,3.033
Portugal,2019,1.718
Portugal,2020,2.859
Portugal,2021,2.859
Portugal,2022,2.859
Portugal,2023,2.859
Portugal,2024,2.859
Kosovo,2015,-1.956
Kosovo,2016,-1.956
Kosovo,2017,-1.956
Kosovo,2018,-1.956
Kosovo,2019,-1.956
Kosovo,2020,-1.956
Kosovo,2021,-1.73
Kosovo,2022,-1.73
Kosovo,2023,-2.189
Kosovo,2024,-2.612
Taiwan,2015,-2.999
Taiwan,2016,-2.999
Taiwan,2017,-3.322
Taiwan,2018,-3.322
Taiwan,2019,-3.845
Taiwan,2020,-3.845
Taiwan,2021,-3.845
Taiwan,2022,-3.845
Taiwan,2023,-3.845
Taiwan,2024,-3.845
Latvia,2015,-2.769
Latvia,2016,-2.769
Latvia,2017,-2.769
Latvia,2018,-3.186
Latvia,2019,-3.186
Latvia,2020,-2.819
Latvia,2021,-2.819
Latvia,2022,-3.276
Latvia,2023,-3.276
Latvia,2024,-3.276
Malawi,2015,2.282
Malawi,2016,2.282
Malawi,2017,2.282
Malawi,2018,2.282
Malawi,2019,2.373
Malawi,2020,2.373
Malawi,2021,1.301
Malawi,2022,1.924
Malawi,2023,1.42
Malawi,2024,2.645
Syria,2015,-1.941
Syria,2016,-1.941
Syria,2017,-1.941
Syria,2018,-1.941
Syria,2019,-2.07
Syria,2020,-2.07
Syria,2021,-1.948
Syria,2022,-1.948
Syria,2023,-2.105
Syria,2024,-2.63
Belarus,2015,0.792
Belarus,2016,0.723
Belarus,2017,0.723
Belarus,2018,0.524
Belarus,2019,-0.323
Belarus,2020,-0.544
Belarus,2021,-2.157
Belarus,2022,-2.157
Belarus,2023,-2.157
Belarus,2024,-3.326
Trinidad and Tobago,2015,1.942
Trinidad and Tobago,2016,1.951
Trinidad and Tobago,2017,1.951
Trinidad and Tobago,2018,1.951
Trinidad and Tobago,2019,1.951
Trinidad and Tobago,2020,2.606
Trinidad and Tobago,2021,2.606
Trinidad and Tobago,2022,2.606
Trinidad and Tobago,2023,2.606
Trinidad and Tobago,2024,2.606
Seychelles,2015,0.723
Seychelles,2016,0.869
Seychelles,2017,0.869
Seychelles,2018,0.869
Seychelles,2019,0.869
Seychelles,2020,0.869
Seychelles,2021,0.869
Seychelles,2022,0.869
Seychelles,2023,1.475
Seychelles,2024,2.402`;

    // Parse CSV data
    const dataByYear = d3.csvParse(csvData, d => {
        return {
            country: d.country_name,
            year: +d.year,
            score: +d.v2smfordom
        };
    });
    
    // Create line chart
    function createLineChart() {
        // Find min and max values
        const minScore = d3.min(dataByYear, d => d.score);
        const maxScore = d3.max(dataByYear, d => d.score);
        
        // Chart dimensions (adjusted for large info box - 690px Ã— 662px, 85% width, 80% height)
        const margin = { top: 20, right: 50, bottom: 40, left: 50 };
        const width = (690 * 0.85) - margin.left - margin.right; // 85% of container width minus margins
        const height = (662 * 0.80) - margin.top - margin.bottom; // 80% of container height minus margins (5% shorter)
        
        // Create SVG for line chart
        const chartContainer = d3.select(".info-box-large");
        chartContainer.select("svg").remove(); // Remove existing chart if any
        
        const svg = chartContainer.append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);
        
        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // X scale (years)
        const xScale = d3.scaleLinear()
            .domain([2015, 2024])
            .range([0, width]);
        
        // Y scale (inverted: most negative at top, most positive at bottom/0)
        const yScale = d3.scaleLinear()
            .domain([minScore, maxScore])
            .range([0, height]); // minScore at top (y=0), maxScore at bottom (y=height)
        
        // Line generator
        const line = d3.line()
            .x(d => xScale(d.year))
            .y(d => yScale(d.score))
            .curve(d3.curveMonotoneX);
        
        // Group data by country
        const countries = d3.group(dataByYear, d => d.country);
        
        // Color scale
        const colorScale = d3.scaleOrdinal()
            .domain(Array.from(countries.keys()))
            .range(d3.schemeCategory10);
        
        // Draw lines first
        const labelData = [];
        countries.forEach((values, country) => {
            const sortedValues = values.sort((a, b) => a.year - b.year);
            
            // Draw the line
            g.append("path")
                .datum(sortedValues)
                .attr("fill", "none")
                .attr("stroke", colorScale(country))
                .attr("stroke-width", country === "Taiwan" ? 3 : 1.5)
                .attr("d", line)
                .attr("opacity", country === "Taiwan" ? 1 : 0.7);
            
            // Store label data for collision detection
            const lastPoint = sortedValues[sortedValues.length - 1];
            labelData.push({
                country: country,
                x: xScale(lastPoint.year) + 5,
                y: yScale(lastPoint.score),
                color: colorScale(country),
                fontSize: country === "Taiwan" ? 11 : 9,
                fontWeight: country === "Taiwan" ? "bold" : "normal"
            });
        });
        
        // Sort labels by y-position to process from top to bottom
        labelData.sort((a, b) => a.y - b.y);
        
        // Collision detection and adjustment
        const minLabelSpacing = 12; // Minimum vertical spacing between labels
        const adjustedLabels = [];
        
        labelData.forEach((label, i) => {
            let adjustedY = label.y;
            
            // Check for collisions with previous labels
            for (let j = 0; j < adjustedLabels.length; j++) {
                const prevLabel = adjustedLabels[j];
                const distance = Math.abs(adjustedY - prevLabel.y);
                
                if (distance < minLabelSpacing) {
                    // If too close, move this label down
                    adjustedY = prevLabel.y + minLabelSpacing;
                }
            }
            
            adjustedLabels.push({
                ...label,
                y: adjustedY
            });
        });
        
        // Draw labels with adjusted positions
        adjustedLabels.forEach(label => {
            g.append("text")
                .attr("x", label.x)
                .attr("y", label.y)
                .attr("dy", "0.35em")
                .attr("fill", label.color)
                .style("font-size", label.fontSize + "px")
                .style("font-weight", label.fontWeight)
                .text(label.country);
        });
        
        // Add X axis
        const xAxis = d3.axisBottom(xScale)
            .tickFormat(d3.format("d"))
            .ticks(10);
        
        const xAxisGroup = g.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(xAxis);
        
        // Rotate year labels 45 degrees
        xAxisGroup.selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-0.5em")
            .attr("dy", "0.5em")
            .attr("transform", "rotate(-45)");
        
        // Add axis label
        xAxisGroup.append("text")
            .attr("x", width / 2)
            .attr("y", 35)
            .attr("fill", "black")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Year");
        
        // Add Y axis (inverted)
        const yAxis = d3.axisLeft(yScale)
            .ticks(8);
        
        g.append("g")
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -40)
            .attr("x", -height / 2)
            .attr("fill", "black")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Score");
        
        // Add label at bottom (y=height position) showing max value - moved lower
        g.append("text")
            .attr("x", width + 5)
            .attr("y", height + 15) // Moved lower to avoid covering country names
            .attr("fill", "black")
            .style("text-anchor", "start")
            .style("font-size", "10px")
            .style("font-weight", "bold")
            .text(maxScore.toFixed(3));
        
        // Add label at top (y=0 position) showing min value - moved higher
        g.append("text")
            .attr("x", width + 5)
            .attr("y", -5) // Moved higher to avoid covering country names
            .attr("dy", "0.35em")
            .attr("fill", "black")
            .style("text-anchor", "start")
            .style("font-size", "10px")
            .style("font-weight", "bold")
            .text(minScore.toFixed(3));
    }
    
    // Initialize line chart when page loads
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', createLineChart);
    } else {
        createLineChart();
    }
    
    // Create military activities line chart
    function createMilitaryChart() {
        console.log("Creating military chart...");
        d3.csv("output_filtered.csv").then(function(data) {
            console.log("CSV data loaded:", data.length, "rows");
            console.log("First few rows:", data.slice(0, 3));
            
            // Parse and filter data
            const parsedData = data
                .filter(d => {
                    // Filter out rows with N/A or zero total sorties
                    const hasNA = d["Aircraft Sorties"] && d["Aircraft Sorties"].includes("N/A");
                    const totalIsZero = d["Total Sorties"] === "0" || d["Total Sorties"] === "";
                    return !hasNA && !totalIsZero;
                })
                .map(d => {
                    const dateStr = d["Date"];
                    const date = new Date(dateStr);
                    const aircraft = d["Aircraft Sorties"] && !d["Aircraft Sorties"].includes("N/A") ? +d["Aircraft Sorties"] : 0;
                    const vessel = d["Vessel Sorties"] && !d["Vessel Sorties"].includes("N/A") ? +d["Vessel Sorties"] : 0;
                    const total = +d["Total Sorties"] || 0;
                    
                    return {
                        date: date,
                        aircraft: aircraft,
                        vessel: vessel,
                        total: total
                    };
                })
                .filter(d => !isNaN(d.date.getTime())) // Filter out invalid dates
                .sort((a, b) => a.date - b.date); // Sort by date, oldest first
            
            console.log("Parsed data:", parsedData.length, "rows");
            console.log("Sample parsed data:", parsedData.slice(0, 3));
            
            if (parsedData.length === 0) {
                console.error("No valid data found after parsing");
                const chartContainer = d3.select(".military-chart");
                chartContainer.append("p")
                    .style("color", "red")
                    .text("No valid data found");
                return;
            }
            
            // Chart dimensions - make it larger and more balanced
            const margin = { top: 30, right: 60, bottom: 70, left: 60 };
            const containerWidth = 500; // Larger width for better balance
            const containerHeight = 400; // Larger height
            const width = containerWidth - margin.left - margin.right;
            const height = containerHeight - margin.top - margin.bottom;
            
            // Clear existing chart
            const chartContainer = d3.select(".military-chart");
            chartContainer.selectAll("*").remove();
            
            // Create SVG
            const svg = chartContainer.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // X scale (dates) - oldest to newest
            const dateExtent = d3.extent(parsedData, d => d.date);
            const xScale = d3.scaleTime()
                .domain([dateExtent[0], dateExtent[1]]) // Explicitly set oldest to newest
                .range([0, width]);
            
            // Y scale (sorties count) - shared scale for all three metrics
            const maxSorties = d3.max(parsedData, d => Math.max(d.aircraft, d.vessel, d.total));
            const yScale = d3.scaleLinear()
                .domain([0, maxSorties * 1.1]) // Add 10% padding at top
                .range([height, 0]);
            
            // Line generators
            const line = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.value))
                .curve(d3.curveMonotoneX);
            
            // Prepare data for each line
            const aircraftData = parsedData.map(d => ({ date: d.date, value: d.aircraft }));
            const vesselData = parsedData.map(d => ({ date: d.date, value: d.vessel }));
            const totalData = parsedData.map(d => ({ date: d.date, value: d.total }));
            
            // Color scale
            const colors = {
                aircraft: "#3b9797",
                vessel: "#16476a",
                total: "#bf092f"
            };
            
            // Draw lines
            g.append("path")
                .datum(aircraftData)
                .attr("fill", "none")
                .attr("stroke", colors.aircraft)
                .attr("stroke-width", 2)
                .attr("d", line);
            
            g.append("path")
                .datum(vesselData)
                .attr("fill", "none")
                .attr("stroke", colors.vessel)
                .attr("stroke-width", 2)
                .attr("d", line);
            
            g.append("path")
                .datum(totalData)
                .attr("fill", "none")
                .attr("stroke", colors.total)
                .attr("stroke-width", 2.5)
                .attr("d", line);
            
            // Add X axis (dates, oldest to newest)
            const xAxis = d3.axisBottom(xScale)
                .ticks(8)
                .tickFormat(d3.timeFormat("%m/%d"));
            
            const xAxisGroup = g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis);
            
            xAxisGroup.selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-0.5em")
                .attr("dy", "0.5em")
                .attr("transform", "rotate(-45)");
            
            // Add X axis label
            xAxisGroup.append("text")
                .attr("x", width / 2)
                .attr("y", 50)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .style("font-size", "12px")
                .text("Date");
            
            // Add Y axis (shared scale for Aircraft, Vessel, and Total Sorties)
            const yAxis = d3.axisLeft(yScale)
                .ticks(6);
            
            const yAxisGroup = g.append("g")
                .call(yAxis);
            
            // Add Y axis label
            yAxisGroup.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -40)
                .attr("x", -height / 2)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .style("font-size", "12px")
                .text("Number of Sorties");
            
            // Add legend
            const legend = g.append("g")
                .attr("transform", `translate(${width - 120}, 10)`);
            
            const legendData = [
                { label: "Aircraft", color: colors.aircraft },
                { label: "Vessel", color: colors.vessel },
                { label: "Total", color: colors.total }
            ];
            
            legendData.forEach((item, i) => {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`);
                
                legendRow.append("line")
                    .attr("x1", 0)
                    .attr("x2", 20)
                    .attr("y1", 0)
                    .attr("y2", 0)
                    .attr("stroke", item.color)
                    .attr("stroke-width", item.label === "Total" ? 2.5 : 2);
                
                legendRow.append("text")
                    .attr("x", 25)
                    .attr("y", 0)
                    .attr("dy", "0.35em")
                    .style("font-size", "11px")
                    .text(item.label);
            });
        }).catch(function(error) {
            console.error("Error loading military data:", error);
            const chartContainer = d3.select(".military-chart");
            chartContainer.append("p")
                .style("color", "red")
                .text("Error loading data: " + error.message);
        });
    }
    
    // Initialize military chart when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', createMilitaryChart);
    } else {
        createMilitaryChart();
    }
    
    const svg = d3.select("#treemap-svg");
    
    // Initialize Leaflet map (free, no API key needed!)
    function initMap() {
        console.log('=== INIT MAP CALLED ===');
        console.log('Leaflet available:', typeof L !== 'undefined');
        console.log('Map element:', document.getElementById('map'));
        
        try {
            // Check if Leaflet is loaded
            if (typeof L === 'undefined') {
                console.error('Leaflet library not loaded. Retrying in 200ms...');
                setTimeout(initMap, 200);
                return;
            }
            
            const mapElement = document.getElementById('map');
            if (!mapElement) {
                console.error('Map element not found!');
                return;
            }
            
            // Check if map element has dimensions
            const rect = mapElement.getBoundingClientRect();
            console.log('Map element dimensions:', rect.width, 'x', rect.height);
            console.log('Map element styles:', window.getComputedStyle(mapElement).height);
            
            // Center on Taiwan
            const taiwanCenter = [23.5, 121.0];
            
            // Initialize Leaflet map with OpenStreetMap tiles (free!)
            console.log('Creating Leaflet map...');
            map = L.map('map', {
                center: taiwanCenter,
                zoom: 7,
                zoomControl: true
            });
            
            console.log('Map created, adding tile layer...');
            
            // Add CartoDB Positron tile layer (cleaner, no administrative boundaries)
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors Â© <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
            
            console.log('Tile layer added. Map should be visible now!');
            
            // Load and add cables GeoJSON layer
            fetch('cables.geojson')
                .then(response => response.json())
                .then(cablesData => {
                    console.log('Cables GeoJSON loaded:', cablesData);
                    
                    // Add cables as a GeoJSON layer
                    const cablesLayer = L.geoJSON(cablesData, {
                        style: function(feature) {
                            return {
                                color: '#ff6b6b', // Red color for cables
                                weight: 2,
                                opacity: 0.8
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            // Add popup with cable information if available
                            if (feature.properties) {
                                const props = feature.properties;
                                let popupContent = '<div style="font-size: 12px;">';
                                if (props.name) popupContent += `<strong>${props.name}</strong><br>`;
                                if (props.owner) popupContent += `Owner: ${props.owner}<br>`;
                                if (props.length) popupContent += `Length: ${props.length}<br>`;
                                popupContent += '</div>';
                                layer.bindPopup(popupContent);
                            }
                            
                            // Add explosion emoji markers at specific locations for each LineString
                            if (feature.geometry && feature.geometry.type === 'LineString') {
                                // Get the index of this feature to determine which marker to use
                                const featureIndex = cablesData.features.indexOf(feature);
                                
                                // Define specific coordinates for each LineString
                                const markerCoords = [
                                    [23.252662957372274, 119.86820017108545], // First LineString
                                    [25.49412292011354, 121.54273753122117]  // Second LineString
                                ];
                                
                                // Add explosion emoji at the specified location
                                if (markerCoords[featureIndex]) {
                                    const markerNumber = 2 - featureIndex; // 2 for first, 1 for second
                                    
                                    // Define incident information
                                    const incidents = {
                                        1: {
                                            title: "Incident 1: Keelung Cable Cut",
                                            date: "January 3, 2025",
                                            description: "A Tanzania-flagged vessel while registered in Cameroon called Shunxin-39, controlled by a Chinese entity, deliberately severed subsea cables near Keelung, disrupting Taiwan's external communications."
                                        },
                                        2: {
                                            title: "Incident 2: Taiwan-Penghu Cable Cut",
                                            date: "February 25, 2025",
                                            description: "A Togolese-registered cargo vessel that severed a submarine communication cable between Taiwan and Penghu."
                                        }
                                    };
                                    
                                    const marker = L.marker(markerCoords[featureIndex], {
                                        icon: L.divIcon({
                                            className: 'explosion-marker',
                                            html: `<div style="text-align: center; line-height: 1;"><span style="font-size: 24px;">ðŸ’¥</span><br><span style="font-size: 14px; font-weight: bold; color: #000; background: rgba(255,255,255,0.8); padding: 2px 4px; border-radius: 3px;">${markerNumber}</span></div>`,
                                            iconSize: [40, 50],
                                            iconAnchor: [20, 25]
                                        })
                                    }).addTo(map);
                                    
                                    console.log('Added explosion marker', markerNumber, 'at:', markerCoords[featureIndex]);
                                    
                                    // Draw line pointing to this coordinate (from map center) - do this after marker is added
                                    // Use setTimeout to ensure marker is rendered first, then draw line behind it
                                    setTimeout(() => {
                                        drawPointerLine(markerCoords[featureIndex]);
                                    }, 10);
                                    
                                    // Draw lines from explosion boxes to their markers
                                    if (markerNumber === 1 || markerNumber === 2) {
                                        if (drawExplosionBoxLinesGlobal) {
                                            drawExplosionBoxLinesGlobal();
                                        }
                                    }
                                }
                            }
                        }
                    }).addTo(map);
                    
                    console.log('Cables layer added to map');
                })
                .catch(error => {
                    console.error('Error loading cables.geojson:', error);
                });
            
            // Function to draw solid lines from explosion boxes to their markers
            drawExplosionBoxLinesGlobal = function drawExplosionBoxLines() {
                if (!map) return;
                
                // Wait for map to be ready
                map.whenReady(function() {
                    // Use the first map's SVG overlay - create it if it doesn't exist
                    let svg = d3.select("#treemap-container svg.map-overlay-svg");
                    
                    if (svg.empty()) {
                        // Create SVG overlay for the first map if it doesn't exist
                        const container = d3.select("#treemap-container");
                        svg = container.append("svg")
                            .attr("class", "map-overlay-svg")
                            .style("position", "absolute")
                            .style("top", 0)
                            .style("left", 0)
                            .style("width", "100%")
                            .style("height", "100%")
                            .style("pointer-events", "none")
                            .style("z-index", 150);
                    }
                    
                    // Update SVG dimensions to match container
                    const containerRect = document.getElementById('treemap-container').getBoundingClientRect();
                    svg.attr("width", containerRect.width)
                       .attr("height", containerRect.height);
                    
                    // Clear existing explosion box lines
                    svg.selectAll(".explosion-box-line").remove();
                    
                    // Get container position relative to map
                    const mapContainer = document.getElementById('map');
                    const mapRect = mapContainer.getBoundingClientRect();
                    const mapContainerRect = document.getElementById('treemap-container').getBoundingClientRect();
                    
                    // Draw line for explosion-box-1 to ðŸ’¥1
                    const explosionBox1 = document.getElementById('explosion-box-1');
                    if (explosionBox1) {
                        const boxRect1 = explosionBox1.getBoundingClientRect();
                        
                        // Calculate box center position relative to container
                        const boxCenterX1 = boxRect1.left - mapContainerRect.left + boxRect1.width / 2;
                        const boxCenterY1 = boxRect1.top - mapContainerRect.top + boxRect1.height / 2;
                        
                        // ðŸ’¥1 marker coordinates: [25.49412292011354, 121.54273753122117]
                        const markerCoords1 = [25.49412292011354, 121.54273753122117];
                        
                        // Project marker coordinates to pixel space
                        const markerPoint1 = map.latLngToContainerPoint(markerCoords1);
                        
                        // Calculate marker position relative to container
                        // Adjust Y position upward by 1/4 of the emoji height (iconSize is [40, 50], so height is 50, 1/4 is 12.5)
                        const markerX1 = markerPoint1.x + (mapRect.left - mapContainerRect.left);
                        const markerY1 = markerPoint1.y + (mapRect.top - mapContainerRect.top) - 12.5;
                        
                        // Draw solid line from box to marker
                        svg.append("line")
                            .attr("class", "explosion-box-line")
                            .attr("data-box", "1")
                            .attr("x1", boxCenterX1)
                            .attr("y1", boxCenterY1)
                            .attr("x2", markerX1)
                            .attr("y2", markerY1)
                            .attr("stroke", "#bf092f")
                            .attr("stroke-width", 2)
                            .attr("stroke-dasharray", "none")
                            .style("pointer-events", "none");
                    }
                    
                    // Draw line for explosion-box-2 to ðŸ’¥2
                    const explosionBox2 = document.getElementById('explosion-box-2');
                    if (explosionBox2) {
                        const boxRect2 = explosionBox2.getBoundingClientRect();
                        
                        // Calculate box center position relative to container
                        const boxCenterX2 = boxRect2.left - mapContainerRect.left + boxRect2.width / 2;
                        const boxCenterY2 = boxRect2.top - mapContainerRect.top + boxRect2.height / 2;
                        
                        // ðŸ’¥2 marker coordinates: [23.252662957372274, 119.86820017108545]
                        const markerCoords2 = [23.252662957372274, 119.86820017108545];
                        
                        // Project marker coordinates to pixel space
                        const markerPoint2 = map.latLngToContainerPoint(markerCoords2);
                        
                        // Calculate marker position relative to container
                        // Adjust Y position upward by 1/4 of the emoji height (iconSize is [40, 50], so height is 50, 1/4 is 12.5)
                        const markerX2 = markerPoint2.x + (mapRect.left - mapContainerRect.left);
                        const markerY2 = markerPoint2.y + (mapRect.top - mapContainerRect.top) - 12.5;
                        
                        // Draw solid line from box to marker
                        svg.append("line")
                            .attr("class", "explosion-box-line")
                            .attr("data-box", "2")
                            .attr("x1", boxCenterX2)
                            .attr("y1", boxCenterY2)
                            .attr("x2", markerX2)
                            .attr("y2", markerY2)
                            .attr("stroke", "#bf092f")
                            .attr("stroke-width", 2)
                            .attr("stroke-dasharray", "none")
                            .style("pointer-events", "none");
                    }
                });
            }
            
            // Function to draw pointer lines to explosion coordinates (from map center)
            function drawPointerLine(coords) {
                if (!map) return;
                
                // Wait for map to be ready
                map.whenReady(function() {
                    const svg = d3.select("#treemap-svg");
                    if (svg.empty()) return;
                    
                    // Get map bounds to calculate a reference point (center of map view)
                    const bounds = map.getBounds();
                    const center = bounds.getCenter();
                    
                    // Project coordinates to pixel space
                    const targetPoint = map.latLngToContainerPoint(coords);
                    const centerPoint = map.latLngToContainerPoint(center);
                    
                    // Get SVG dimensions
                    const svgRect = document.getElementById('treemap-svg').getBoundingClientRect();
                    const mapRect = document.getElementById('map').getBoundingClientRect();
                    
                    // Calculate offset between map and SVG
                    const offsetX = svgRect.left - mapRect.left;
                    const offsetY = svgRect.top - mapRect.top;
                    
                    // Adjust coordinates for SVG position
                    const startX = centerPoint.x + offsetX;
                    const startY = centerPoint.y + offsetY;
                    const endX = targetPoint.x + offsetX;
                    const endY = targetPoint.y + offsetY-2;
                    
                    // Draw line - insert at the beginning so it appears behind other elements
                    svg.insert("line", ":first-child")
                        .attr("x1", startX)
                        .attr("y1", startY)
                        .attr("x2", endX)
                        .attr("y2", endY)
                        .attr("stroke", "#bf092f")
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "5,5")
                        .attr("opacity", 0.7)
                        .attr("class", "pointer-line")
                        .lower(); // Move to bottom of z-order
                });
            }
            
            // Function to update pointer lines on map move/zoom
            function updatePointerLines() {
                if (!map) return;
                
                const svg = d3.select("#treemap-svg");
                svg.selectAll(".pointer-line").remove();
                
                // Redraw lines to both coordinates
                const coords = [
                    [25.49412292011354, 121.54273753122117],
                    [23.252662957372274, 119.86820017108545]
                ];
                
                coords.forEach(coord => {
                    const bounds = map.getBounds();
                    const center = bounds.getCenter();
                    
                    const targetPoint = map.latLngToContainerPoint(coord);
                    const centerPoint = map.latLngToContainerPoint(center);
                    
                    const svgRect = document.getElementById('treemap-svg').getBoundingClientRect();
                    const mapRect = document.getElementById('map').getBoundingClientRect();
                    
                    const offsetX = svgRect.left - mapRect.left;
                    const offsetY = svgRect.top - mapRect.top;
                    
                    const startX = centerPoint.x + offsetX;
                    const startY = centerPoint.y + offsetY;
                    const endX = targetPoint.x + offsetX;
                    const endY = targetPoint.y + offsetY;
                    
                    // Draw line - insert at the beginning so it appears behind other elements
                    svg.insert("line", ":first-child")
                        .attr("x1", startX)
                        .attr("y1", startY)
                        .attr("x2", endX)
                        .attr("y2", endY)
                        .attr("stroke", "#bf092f")
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "5,5")
                        .attr("opacity", 0.7)
                        .attr("class", "pointer-line")
                        .lower(); // Move to bottom of z-order
                });
                
                // Redraw explosion box lines
                if (drawExplosionBoxLinesGlobal) {
                    drawExplosionBoxLinesGlobal();
                }
            }
            
            // Force map to invalidate size in case of layout issues
            setTimeout(function() {
                console.log('Invalidating map size...');
                map.invalidateSize();
            }, 200);
            
            // Load GeoJSON and draw treemap after map is ready
            map.whenReady(function() {
                console.log('Map is ready, checking for GeoJSON data...');
                console.log('geojsonData available:', !!geojsonData);
                
                if (geojsonData) {
                    console.log('Drawing treemap with existing GeoJSON data...');
                    drawTreemap(geojsonData);
                } else {
                    console.log('GeoJSON not loaded yet, will draw when it loads');
                }
            });
            
            // Redraw treemap on zoom and pan
            map.on('moveend', function() {
                if (geojsonData) {
                    drawTreemap(geojsonData);
                }
                if (typeof updatePointerLines === 'function') {
                    updatePointerLines();
                }
            });
            
            map.on('zoomend', function() {
                if (geojsonData) {
                    drawTreemap(geojsonData);
                }
                if (typeof updatePointerLines === 'function') {
                    updatePointerLines();
                }
            });
        } catch (error) {
            console.error('Error initializing map:', error);
            console.error('Error stack:', error.stack);
            const mapElement = document.getElementById('map');
            if (mapElement) {
                mapElement.innerHTML = '<div style="padding: 20px; text-align: center; color: red; background: white; z-index: 1000;">Error: ' + error.message + '<br>Check console for details.</div>';
            }
        }
    }
    
    // Wait for DOM and scripts to be ready
    function startInit() {
        console.log('=== STARTING INITIALIZATION ===');
        console.log('Document ready state:', document.readyState);
        console.log('Leaflet loaded:', typeof L !== 'undefined');
        console.log('Map div exists:', !!document.getElementById('map'));
        
        if (typeof L === 'undefined') {
            console.log('Leaflet not loaded yet, waiting...');
            setTimeout(startInit, 100);
            return;
        }
        
        if (!document.getElementById('map')) {
            console.log('Map div not found yet, waiting...');
            setTimeout(startInit, 100);
            return;
        }
        
        initMap();
    }
    
    // Start initialization
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startInit);
    } else {
        // DOM already loaded, but wait a bit for scripts
        setTimeout(startInit, 100);
    }
    
    // --- 1. Define Color Scales ---
    const colorRed = d3.scaleLinear()
        .domain([-3.845, -2.612]) // Min and Max negative scores
        .range(["#000000", "#1d81a2"]); // Deep Red to Light Red
    
    const colorGreen = d3.scaleLinear()
        .domain([2.402, 2.859]) // Min and Max positive scores
        .range(["#398564", "#fdfff5"]); // Light Green to Bright Green
    
    const getColor = (d) => {
        if (d.data.Category === 'Red') {
            return colorRed(d.data.Score);
        } else {
            return colorGreen(d.data.Score);
        }
    };
    
    // Find darkest blocks for text color determination
    const redScores = data.filter(d => d.Category === 'Red').map(d => d.Score);
    const greenScores = data.filter(d => d.Category === 'Green').map(d => d.Score);
    const darkestRed = Math.min(...redScores); // Most negative (darkest)
    const darkestGreen = Math.max(...greenScores); // Most positive (darkest)
    
    const getTextColor = (d) => {
        if (d.data.Category === 'Red') {
            return 'white'; // Darkest red block
        }  else {
            return 'black'; // All other blocks
        }
    };
    
    // Function to project lat/lng to pixel coordinates using Leaflet projection
    function projectLatLngToPixel(lat, lng) {
        if (!map) return null;
        
        // Leaflet's latLngToContainerPoint converts lat/lng to pixel coordinates
        const point = map.latLngToContainerPoint([lat, lng]);
        
        return [point.x, point.y];
    }
    
    // Function to draw/redraw the treemap
    function drawTreemap(geojson) {
        console.log('=== DRAWING TREEMAP ===');
        console.log('SVG element:', svg.node());
        console.log('SVG current content children:', svg.node() ? svg.node().children.length : 'no node');
        
        // Clear existing content (but keep test circle for now)
        const beforeClear = svg.node() ? svg.node().children.length : 0;
        console.log('SVG children before clear:', beforeClear);
        svg.selectAll("g, path, defs").remove();
        const afterClear = svg.node() ? svg.node().children.length : 0;
        console.log('SVG children after clear:', afterClear);
        
        // Get current dimensions - check if we're in section 2 or original container
        const section2Container = document.getElementById("treemap-container-section2");
        const originalContainer = document.getElementById("treemap-container");
        const containerRect = section2Container ? section2Container.getBoundingClientRect() : originalContainer.getBoundingClientRect();
        const width = containerRect.width;
        const height = containerRect.height;
        
        console.log('Container dimensions:', width, 'x', height);
        
        // Set SVG dimensions
        svg.attr("width", width).attr("height", height);
        
        if (!geojson || !geojson.features || geojson.features.length === 0) {
            console.error("Failed to load or parse taiwan.geojson, or it's empty.");
            return;
        }
        
        if (!map) {
            console.log("Map not ready yet, will retry...");
            return;
        }
        
        console.log('GeoJSON features:', geojson.features.length);
    
        // Assuming the GeoJSON contains one main feature for Taiwan
        const taiwanFeature = geojson.features[0];
    
        // Project coordinates using Leaflet projection
        function projectCoordinates(coords) {
            if (Array.isArray(coords[0])) {
                return coords.map(projectCoordinates);
            }
            // coords is [lng, lat] in GeoJSON format
            const pixel = projectLatLngToPixel(coords[1], coords[0]);
            return pixel || [0, 0];
        }
        
        // Get the geometry and project it
        const geometry = taiwanFeature.geometry;
        let outerRing;
        
        if (geometry.type === 'Polygon') {
            outerRing = geometry.coordinates[0];
        } else if (geometry.type === 'MultiPolygon') {
            outerRing = geometry.coordinates[0][0]; // First polygon, outer ring
        } else {
            console.error('Unsupported geometry type:', geometry.type);
            return;
        }
        
        const projectedPoints = outerRing.map(coord => projectCoordinates(coord));
        
        console.log('Projected points sample (first 3):', projectedPoints.slice(0, 3));
        
        // Filter out invalid points (points that are null or [0, 0])
        const validPoints = projectedPoints.filter(p => p && (p[0] !== 0 || p[1] !== 0));
        
        console.log('Valid points:', validPoints.length, 'out of', projectedPoints.length);
        
        if (validPoints.length === 0) {
            console.error("No valid projected points");
            return;
        }
        
        // Close the path if needed
        if (validPoints.length > 0 && 
            (validPoints[0][0] !== validPoints[validPoints.length - 1][0] ||
             validPoints[0][1] !== validPoints[validPoints.length - 1][1])) {
            validPoints.push(validPoints[0]);
        }
        
        // Create path data for Taiwan outline
        const taiwanPathData = "M" + validPoints.map(p => `${p[0]},${p[1]}`).join("L") + "Z";
        
        console.log('Taiwan path created, length:', taiwanPathData.length);
    
        // Define a clip path for the Taiwan shape
        console.log('Creating clip path...');
        const defs = svg.append("defs");
        const clipPath = defs.append("clipPath")
            .attr("id", "taiwan-clip");
        clipPath.append("path")
            .attr("d", taiwanPathData);
        console.log('Clip path created');
    
        // Taiwan outline removed - the map already shows Taiwan's boundaries
    
        // --- 3. Prepare Data for Voronoi Treemap ---
        const root = d3.hierarchy({ children: data })
            .sum(d => d.Size)
            .sort((a, b) => b.value - a.value);
    
        // --- 4. Initialize the Voronoi Treemap Layout ---
        if (typeof d3.voronoiTreemap === 'undefined') {
            console.error('d3-voronoi-treemap library not loaded!');
            return;
        }
    
        const voronoiTreemap = d3.voronoiTreemap()
            .clip(validPoints.slice(0, -1)); // Remove the closing point for clipping
    
        try {
            console.log('Computing voronoi treemap...');
            voronoiTreemap(root);
            console.log('Voronoi treemap computed successfully');
        } catch (error) {
            console.error('Error computing treemap:', error);
            console.error('Error stack:', error.stack);
            return;
        }
    
        // --- 6. Drawing the Cells (Polygons) ---
        console.log('Creating cells group...');
        const cellsGroup = svg.append("g")
            .attr("clip-path", "url(#taiwan-clip)");
        console.log('Cells group created:', cellsGroup.node());
    
        const leaves = root.leaves();
        console.log('Number of leaves (cells) to draw:', leaves.length);
        console.log('Sample leaf data:', leaves[0] ? {
            country: leaves[0].data.Country,
            hasPolygon: !!leaves[0].polygon,
            polygonLength: leaves[0].polygon ? leaves[0].polygon.length : 0
        } : 'no leaves');
        
        const cell = cellsGroup.selectAll(".cell")
            .data(leaves)
            .enter().append("g")
            .attr("class", "cell");
        
        console.log('Cell groups created:', cell.size());
    
        // Create tooltip element
        const tooltip = d3.select("#tooltip");
        
        console.log('Appending paths to cells...');
        const paths = cell.append("path")
            .attr("d", d => {
                if (!d.polygon || d.polygon.length === 0) {
                    console.warn('Cell has no polygon:', d.data.Country);
                    return null;
                }
                const pathData = "M" + d.polygon.map(p => `${p[0]},${p[1]}`).join("L") + "Z";
                return pathData;
            })
            .attr("fill", d => getColor(d))
            .on("mouseover", function(event, d) {
                // Show tooltip
                tooltip.select(".tooltip-title")
                    .text(d.data.Country);
                
                // Get rank (handle both "Rank" and "rank" cases)
                const rank = d.data.Rank || d.data.rank;
                
                tooltip.select(".tooltip-content")
                    .html(`Rank: ${rank}<br>` +
                          `Score: ${d.data.Score.toFixed(3)}<br>` +
                          `Category: ${d.data.Category}<br>` +
                          `Size: ${d.data.Size.toFixed(3)}`);
                
                tooltip.classed("visible", true);
            })
            .on("mouseout", function() {
                // Hide tooltip
                tooltip.classed("visible", false);
            })
            .on("mousemove", function(event) {
                // Follow mouse cursor
                const section2Container = document.getElementById("treemap-container-section2");
                const originalContainer = document.getElementById("treemap-container");
                const containerRect = section2Container ? section2Container.getBoundingClientRect() : originalContainer.getBoundingClientRect();
                const tooltipNode = tooltip.node();
                const tooltipWidth = tooltipNode.offsetWidth || 150;
                const tooltipHeight = tooltipNode.offsetHeight || 80;
                
                // Position tooltip near cursor, offset to avoid covering the cursor
                let left = event.pageX - containerRect.left + 15;
                let top = event.pageY - containerRect.top - tooltipHeight - 10;
                
                // Keep tooltip within container bounds
                if (left + tooltipWidth > containerRect.width) {
                    left = event.pageX - containerRect.left - tooltipWidth - 15;
                }
                if (top < 0) {
                    top = event.pageY - containerRect.top + 15;
                }
                
                tooltip
                    .style("left", `${left}px`)
                    .style("top", `${top}px`);
            });
        
        console.log('Cells drawn:', cell.size());
    
        // --- 7. Add Labels (UPDATED LOGIC) ---
        cell.append("text")
            .attr("class", d => {
                // Add special class for Taiwan
                return d.data.Country === 'Taiwan' ? "country-label taiwan-label" : "country-label";
            })
            .attr("transform", d => `translate(${d3.polygonCentroid(d.polygon)})`) // Position at centroid
            .style("fill", d => getTextColor(d)) // Set text color based on block darkness
            .style("stroke", "none") // Explicitly remove stroke/outline
            .selectAll("tspan")
            .data(d => {
                // Data array to hold both the Country Name and the Score
                const labels = [];
                
                // 1. Country Name (can be shortened for small cells)
                const name = d.data.Country;
                const isTaiwan = name === 'Taiwan';
                if (!isTaiwan && d.value / root.value < 0.05) { // Heuristic: If cell is very small, use abbreviation
                    labels.push(name.substring(0, 3) + '.');
                } else {
                    labels.push(name);
                }
                
                // 2. Score Value
                labels.push(d.data.Score.toFixed(3)); 
                
                return labels;
            })
            .enter().append("tspan")
            .attr("x", 0) // Centered
            .attr("dy", (d, i) => { 
                 // First line (Country Name) is slightly above center
                 if (i === 0) return "-0.5em";
                 // Second line (Score Value) is on the baseline
                 return "1.2em"; 
            })
            .style("font-size", function(d, i) {
                // Check if parent text has taiwan-label class
                const isTaiwan = d3.select(this.parentNode).classed("taiwan-label");
                if (isTaiwan) {
                    return i === 1 ? "12px" : "14px"; // Larger font for Taiwan
                }
                return i === 1 ? "7px" : "8px"; // Normal size for others
            })
            .style("font-weight", (d, i) => i === 1 ? "normal" : "bold") // Country name bold
            .text(d => d);
    
        // Taiwan outline removed
    }
    
    // --- 2. Load Taiwan GeoJSON and draw treemap ---
    let geojsonData = null;
    
    // Initialize treemap for section 2 (with map background)
    let mapSection2 = null;
    function initTreemapSection2() {
        // Initialize Leaflet map for section 2
        const mapElement2 = document.getElementById('map-section2');
        if (!mapElement2) {
            console.error('Map section 2 element not found!');
            return;
        }
        
        mapSection2 = L.map('map-section2').setView([23.5, 121.0], 8);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors Â© <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(mapSection2);
        
        // Load GeoJSON and draw treemap for section 2 after map is ready
        mapSection2.whenReady(function() {
            d3.json("taiwan.geojson").then(function(geojson) {
                console.log('GeoJSON loaded for section 2:', geojson);
                if (!geojson || !geojson.features || geojson.features.length === 0) {
                    console.error('Invalid GeoJSON loaded for section 2');
                    return;
                }
                
                // Store geojson for later use
                window.geojsonSection2 = geojson;
                
                // Invalidate map size to ensure it's properly rendered
                mapSection2.invalidateSize();
                
                // Initial draw with a small delay to ensure map is fully rendered
                setTimeout(function() {
                    drawTreemapSection2(geojson);
                }, 300);
                
                // Update treemap on map move/zoom for section 2
                mapSection2.on('moveend', function() {
                    console.log('Map section 2 moveend event fired - redrawing treemap and labels');
                    if (window.geojsonSection2) {
                        // Small delay to ensure map has finished moving
                        setTimeout(function() {
                            drawTreemapSection2(window.geojsonSection2);
                        }, 50);
                    } else {
                        console.log('geojsonSection2 not available');
                    }
                });
                
                mapSection2.on('zoomend', function() {
                    console.log('Map section 2 zoomend event fired - redrawing treemap and labels');
                    if (window.geojsonSection2) {
                        // Small delay to ensure map has finished zooming
                        setTimeout(function() {
                            drawTreemapSection2(window.geojsonSection2);
                        }, 50);
                    } else {
                        console.log('geojsonSection2 not available');
                    }
                });
            }).catch(function(error) {
                console.error('Error loading GeoJSON for section 2:', error);
            });
        });
    }
    
    // Draw treemap for section 2 with map background
    function drawTreemapSection2(geojson) {
        if (!mapSection2) {
            console.log('mapSection2 not available');
            return;
        }
        
        // Select SVG within section 2 container
        const section2Container = document.getElementById("treemap-container-section2");
        if (!section2Container) {
            console.log('Section 2 container not found');
            return;
        }
        
        const svg = d3.select(section2Container).select("svg#treemap-svg");
        if (svg.empty()) {
            console.log('SVG #treemap-svg not found in section 2');
            return;
        }
        
        console.log('Drawing treemap for section 2');
        
        // Clear existing content (including all groups and paths, which includes labels)
        svg.selectAll("g, path").remove();
        // Only remove defs if we're going to recreate them
        const existingDefs = svg.select("defs");
        if (!existingDefs.empty()) {
            existingDefs.remove();
        }
        
        console.log('Section 2 - Cleared all content (cells and labels), about to redraw');
        
        // Get container dimensions (section2Container already defined above)
        const containerRect = section2Container.getBoundingClientRect();
        const width = containerRect.width;
        const height = containerRect.height;
        
        // Set SVG dimensions
        svg.attr("width", width).attr("height", height);
        
        if (!geojson || !geojson.features || geojson.features.length === 0) {
            console.error("Failed to load or parse taiwan.geojson for section 2");
            return;
        }
        
        // Project coordinates using Leaflet map projection
        // latLngToContainerPoint returns coordinates relative to the map's container
        // Since both map and SVG are absolutely positioned at (0,0) in the same parent,
        // the coordinates should align directly
        function projectLatLngToPixel(lat, lng) {
            const point = mapSection2.latLngToContainerPoint([lat, lng]);
            // Use coordinates directly - both containers are at the same position
            return [point.x, point.y];
        }
        
        function projectCoordinates(coords) {
            if (!coords || !Array.isArray(coords) || coords.length < 2) {
                console.warn('Invalid coordinates in projectCoordinates:', coords);
                return [0, 0];
            }
            if (Array.isArray(coords[0])) {
                return coords.map(projectCoordinates);
            }
            // coords is [lng, lat] in GeoJSON format
            const pixel = projectLatLngToPixel(coords[1], coords[0]);
            return pixel || [0, 0];
        }
        
        // Extract outer ring coordinates
        if (!geojson.features || geojson.features.length === 0) {
            console.error('GeoJSON has no features');
            return;
        }
        
        const geometry = geojson.features[0].geometry;
        if (!geometry || !geometry.coordinates) {
            console.error('Geometry or coordinates missing');
            return;
        }
        
        let outerRing;
        
        if (geometry.type === 'Polygon') {
            if (!geometry.coordinates[0]) {
                console.error('Polygon has no coordinates');
                return;
            }
            outerRing = geometry.coordinates[0];
        } else if (geometry.type === 'MultiPolygon') {
            if (!geometry.coordinates[0] || !geometry.coordinates[0][0]) {
                console.error('MultiPolygon has no coordinates');
                return;
            }
            outerRing = geometry.coordinates[0][0];
        } else {
            console.error('Unsupported geometry type:', geometry.type);
            return;
        }
        
        if (!outerRing || outerRing.length === 0) {
            console.error('Outer ring is empty');
            return;
        }
        
        const projectedPoints = outerRing.map(coord => projectCoordinates(coord));
        const validPoints = projectedPoints.filter(p => p && (p[0] !== 0 || p[1] !== 0));
        
        console.log('Section 2 - Valid points:', validPoints.length, 'out of', projectedPoints.length);
        
        // Check if data is available
        if (typeof data === 'undefined' || !data || data.length === 0) {
            console.error('Data is not available for treemap in section 2');
            return;
        }
        
        if (validPoints.length < 3) {
            console.error('Not enough valid points for clipping:', validPoints.length);
            return;
        }
        
        // Close the path if needed
        if (validPoints.length > 0 && 
            (validPoints[0][0] !== validPoints[validPoints.length - 1][0] ||
             validPoints[0][1] !== validPoints[validPoints.length - 1][1])) {
            validPoints.push(validPoints[0]);
        }
        
        // Create path data for Taiwan outline
        const taiwanPathData = "M" + validPoints.map(p => `${p[0]},${p[1]}`).join("L") + "Z";
        
        // Define a clip path for the Taiwan shape
        // Remove existing defs first to avoid duplicates
        svg.select("defs#taiwan-defs-section2").remove();
        const defs = svg.append("defs")
            .attr("id", "taiwan-defs-section2");
        const clipPath = defs.append("clipPath")
            .attr("id", "taiwan-clip-section2");
        clipPath.append("path")
            .attr("d", taiwanPathData);
        
        // Create Voronoi treemap
        const voronoiTreemap = d3.voronoiTreemap()
            .clip(validPoints.slice(0, -1)); // Remove closing point for clipping
        
        const root = d3.hierarchy({ children: data })
            .sum(d => d.Size)
            .sort((a, b) => b.value - a.value);
        
        try {
            voronoiTreemap(root);
            console.log('Section 2 - Voronoi treemap computed successfully');
        } catch (error) {
            console.error('Error computing voronoi treemap:', error);
            return;
        }
        
        // Create cells group with clip path
        const cellsGroup = svg.append("g")
            .attr("clip-path", "url(#taiwan-clip-section2)");
        
        // Draw cells using leaves (like the working version)
        const leaves = root.leaves();
        console.log('Section 2 - Number of leaves (cells):', leaves.length);
        
        const cells = cellsGroup.selectAll(".cell")
            .data(leaves)
            .enter().append("g")
            .attr("class", "cell");
        
        cells.append("path")
            .attr("d", d => {
                if (!d.polygon || !Array.isArray(d.polygon) || d.polygon.length === 0) {
                    return '';
                }
                return `M${d.polygon.map(p => Array.isArray(p) && p.length >= 2 ? p.join(',') : '0,0').join('L')}Z`;
            })
            .attr("fill", getColor)
            .attr("stroke", "#fff")
            .attr("stroke-width", 1)
            .on("mouseover", function(event, d) {
                const tooltip = d3.select("#tooltip");
                tooltip.style("opacity", 1);
                tooltip.select(".tooltip-title").text(d.data.Country);
                tooltip.select(".tooltip-content").html(
                    `Score: ${d.data.Score.toFixed(3)}<br>` +
                    `Rank: ${d.data.Rank}`
                );
            })
            .on("mousemove", function(event) {
                const tooltip = d3.select("#tooltip");
                const containerRect = section2Container.getBoundingClientRect();
                tooltip.style("left", (event.pageX - containerRect.left + 15) + "px")
                    .style("top", (event.pageY - containerRect.top - 10) + "px");
            })
            .on("mouseout", function() {
                d3.select("#tooltip").style("opacity", 0);
            });
        
        // Add labels using leaves (same as working version)
        const labelsGroup = svg.append("g")
            .attr("clip-path", "url(#taiwan-clip-section2)")
            .attr("class", "labels-group-section2");
        
        // Helper function to get text color based on block darkness
        function getTextColor(d) {
            const color = getColor(d);
            const rgb = d3.rgb(color);
            const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            return brightness < 128 ? "white" : "black";
        }
        
        // Filter leaves that have valid data and polygons
        const validLeaves = leaves.filter(d => {
            const hasData = d.data && d.data.Country;
            const hasPolygon = d.polygon && Array.isArray(d.polygon) && d.polygon.length > 0;
            return hasData && hasPolygon;
        });
        
        // Calculate centroids for all valid leaves
        validLeaves.forEach(d => {
            if (d.polygon && Array.isArray(d.polygon) && d.polygon.length > 0) {
                try {
                    d.polygonCentroid = d3.polygonCentroid(d.polygon);
                } catch (e) {
                    console.warn('Error calculating centroid for', d.data.Country, e);
                    d.polygonCentroid = null;
                }
            }
        });
        
        // Filter again to only include leaves with valid centroids
        const leavesWithCentroids = validLeaves.filter(d => 
            d.polygonCentroid && Array.isArray(d.polygonCentroid) && d.polygonCentroid.length >= 2
        );
        
        console.log('Section 2 - Valid leaves for labels:', leavesWithCentroids.length, 'out of', leaves.length);
        
        // Explicitly clear any existing labels to ensure clean state when map moves/zooms
        labelsGroup.selectAll(".country-label").remove();
        
        // Create labels for all valid leaves
        const labelSelection = labelsGroup.selectAll(".country-label")
            .data(leavesWithCentroids, d => d.data.Country); // Use key function to track by country name
        
        // Remove old labels (shouldn't be any after clear, but keep for safety)
        labelSelection.exit().remove();
        
        // Add new labels
        const newLabels = labelSelection.enter()
            .append("text")
            .attr("class", d => d.data.Country === 'Taiwan' ? "country-label taiwan-label" : "country-label");
        
        // Update existing labels and add new ones
        const allLabels = labelSelection.merge(newLabels);
        
        // Update all labels (both new and existing) with transform and styles
        allLabels
            .attr("transform", d => {
                if (!d.polygonCentroid || !Array.isArray(d.polygonCentroid) || d.polygonCentroid.length < 2) {
                    console.warn('Invalid centroid for', d.data.Country, d.polygonCentroid);
                    return 'translate(0,0)';
                }
                return `translate(${d.polygonCentroid[0]},${d.polygonCentroid[1]})`;
            })
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .style("fill", d => getTextColor(d))
            .style("stroke", "none");
        
        // Handle tspan elements for multi-line labels
        allLabels.each(function(d) {
            const textElement = d3.select(this);
            // Remove existing tspans
            textElement.selectAll("tspan").remove();
            
            // Data array to hold both the Country Name and the Score
            const labels = [];
            
            // 1. Country Name (can be shortened for small cells)
            const name = d.data.Country;
            const isTaiwan = name === 'Taiwan';
            if (!isTaiwan && d.value / root.value < 0.05) { // Heuristic: If cell is very small, use abbreviation
                labels.push(name.substring(0, 3) + '.');
            } else {
                labels.push(name);
            }
            
            // 2. Score Value
            labels.push(d.data.Score.toFixed(3)); 
            
            // Add tspans
            labels.forEach((labelText, i) => {
                textElement.append("tspan")
                    .attr("x", 0) // Centered
                    .attr("dy", i === 0 ? "-0.5em" : "1.2em")
                    .style("font-size", function() {
                        const isTaiwan = d3.select(this.parentNode).classed("taiwan-label");
                        if (isTaiwan) {
                            return i === 1 ? "12px" : "14px"; // Larger font for Taiwan
                        }
                        return i === 1 ? "7px" : "8px"; // Normal size for others
                    })
                    .style("font-weight", i === 1 ? "normal" : "bold") // Country name bold
                    .text(labelText);
            });
        });
        
        console.log('Section 2 - Labels added/updated:', allLabels.size());
            
    }
    
    d3.json("taiwan.geojson").then(function(geojson) {
        console.log('GeoJSON loaded successfully');
        console.log('GeoJSON features:', geojson.features ? geojson.features.length : 'none');
        geojsonData = geojson;
        // Don't draw treemap on the original map anymore - only draw it in section 2
        
        // Initialize section 2 treemap after a delay to ensure DOM is ready
        setTimeout(() => {
            if (document.getElementById('treemap-container-section2')) {
                initTreemapSection2();
                // Draw treemap in section 2 after map is initialized
                setTimeout(() => {
                    drawTreemap(geojson);
                }, 500);
            }
        }, 1000);
    }).catch(function(error) {
        console.error("Error loading GeoJSON or creating treemap:", error);
        console.error("Error details:", error);
    });
    
    // Handle window resize with debouncing
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            if (geojsonData && map) {
                drawTreemap(geojsonData);
            }
        }, 250); // Wait 250ms after resize stops
    });
    
    // Make info boxes draggable
    function makeDraggable(element) {
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;
        
        const container = document.getElementById("treemap-container");
        const header = element.querySelector('h3');
        
        // For explosion-info-box (no header), make the whole element draggable
        // For info-box (with header), only drag by header
        if (header) {
            header.addEventListener('mousedown', dragStart);
        } else {
            // No header, make entire element draggable
            element.addEventListener('mousedown', dragStart);
        }
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        
        function dragStart(e) {
            if (e.button !== 0) return; // Only left mouse button
            
            // If there's a header, only start dragging if clicking on header
            if (header && e.target !== header && !header.contains(e.target)) {
                return;
            }
            
            isDragging = true;
            element.classList.add('dragging');
            
            // Get current position
            const rect = element.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            xOffset = rect.left - containerRect.left;
            yOffset = rect.top - containerRect.top;
            
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
        }
        
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                
                xOffset = currentX;
                yOffset = currentY;
                
                // Get container bounds
                const containerRect = container.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                // Constrain to container bounds
                const minX = 0;
                const minY = 0;
                const maxX = containerRect.width - elementRect.width;
                const maxY = containerRect.height - elementRect.height;
                
                xOffset = Math.max(minX, Math.min(maxX, xOffset));
                yOffset = Math.max(minY, Math.min(maxY, yOffset));
                
                // Remove right/bottom positioning and use left/top
                element.style.right = 'auto';
                element.style.bottom = 'auto';
                element.style.left = xOffset + 'px';
                element.style.top = yOffset + 'px';
                
                // Update explosion box lines in real-time while dragging
                if ((element.id === 'explosion-box-1' || element.id === 'explosion-box-2') && drawExplosionBoxLinesGlobal) {
                    drawExplosionBoxLinesGlobal();
                }
            }
        }
        
        function dragEnd(e) {
            if (isDragging) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
                element.classList.remove('dragging');
                
                // Redraw explosion box lines if this is an explosion box
                if ((element.id === 'explosion-box-1' || element.id === 'explosion-box-2') && drawExplosionBoxLinesGlobal) {
                    drawExplosionBoxLinesGlobal();
                }
            }
        }
    }
    
    // Make info boxes resizable
    function makeResizable(element) {
        const resizeHandle = element.querySelector('.resize-handle');
        if (!resizeHandle) return;
        
        let isResizing = false;
        let startX, startY, startWidth, startHeight;
        
        resizeHandle.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            isResizing = true;
            element.classList.add('resizing');
            
            const rect = element.getBoundingClientRect();
            startX = e.clientX;
            startY = e.clientY;
            startWidth = rect.width;
            startHeight = rect.height;
            
            document.addEventListener('mousemove', handleResize);
            document.addEventListener('mouseup', stopResize);
        });
        
        function handleResize(e) {
            if (!isResizing) return;
            
            const container = document.getElementById("treemap-container");
            const containerRect = container.getBoundingClientRect();
            
            // Calculate new dimensions
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            let newWidth = startWidth + deltaX;
            let newHeight = startHeight + deltaY;
            
            // Get current position
            const currentLeft = parseInt(window.getComputedStyle(element).left) || 0;
            const currentTop = parseInt(window.getComputedStyle(element).top) || 0;
            
            // Constrain to container bounds and minimum size
            const minWidth = 200;
            const minHeight = 150;
            const maxWidth = containerRect.width - currentLeft;
            const maxHeight = containerRect.height - currentTop;
            
            newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
            newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
            
            // Apply new dimensions
            element.style.width = newWidth + 'px';
            element.style.height = newHeight + 'px';
        }
        
        function stopResize() {
            if (isResizing) {
                isResizing = false;
                element.classList.remove('resizing');
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            }
        }
    }
    
    // Initialize dragging and resizing for floating info boxes only (not section boxes)
    function initDraggableBoxes() {
        // Handle both treemap-container and cable-container (in case ID was changed)
        const containers = ['#treemap-container', '#cable-container'];
        containers.forEach(containerSelector => {
            const container = document.querySelector(containerSelector);
            if (!container) return;
            
            const infoBoxes = container.querySelectorAll('.info-box');
            infoBoxes.forEach(box => {
                makeDraggable(box);
                makeResizable(box);
            });
            
            // Also make explosion-info-box elements draggable
            const explosionBoxes = container.querySelectorAll('.explosion-info-box');
            explosionBoxes.forEach(box => {
                makeDraggable(box);
            });
        });
        
        // Explicitly ensure info-box-bottom is draggable and resizable
        const infoBoxBottom = document.getElementById('info-box-bottom');
        if (infoBoxBottom) {
            makeDraggable(infoBoxBottom);
            makeResizable(infoBoxBottom);
            console.log('info-box-bottom initialized as draggable and resizable');
        }
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDraggableBoxes);
    } else {
        initDraggableBoxes();
    }
    
    // Image Modal Functions
    function openImageModal(imageSrc) {
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');
        modal.classList.add('active');
        modalImg.src = imageSrc;
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
    }
    
    function closeImageModal() {
        const modal = document.getElementById('imageModal');
        modal.classList.remove('active');
        document.body.style.overflow = 'auto'; // Restore scrolling
    }
    
    // Close modal on Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            closeImageModal();
        }
    });
    
    </script>
    
    <!-- Image Modal -->
    <div id="imageModal" class="image-modal" onclick="closeImageModal()">
        <span class="image-modal-close" onclick="event.stopPropagation(); closeImageModal();">&times;</span>
        <img id="modalImage" class="image-modal-content" src="" alt="Enlarged image" onclick="event.stopPropagation();">
    </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <title>Taiwan Voronoi Treemap</title>
    <!-- Google Fonts - Noto Sans TC for Traditional Chinese support -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          crossorigin=""/>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        
        .headline {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #16476a 0%, #3b9797 100%);
            color: white;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        #treemap-container {
            position: relative; /* Needed for tooltip positioning */
            width: 100vw;
            height: calc(100vh - 77px);
            margin: 0;
        }

        #map {
            width: 100%;
            height: 100%;
            z-index: 0; /* Ensure map is behind SVG overlay */
            min-height: 400px; /* Ensure map has minimum height */
            background-color: #e0e0e0; /* Temporary background to see if div exists */
        }
        
        /* Leaflet map container styles */
        .leaflet-container {
            background: #f0f0f0;
            height: 100% !important;
            width: 100% !important;
        }

        #treemap-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow map interaction to pass through */
            z-index: 100; /* Ensure SVG is above the map */
            background: transparent; /* Make sure it's transparent, not blocking */
        }

        #treemap-svg .cell {
            pointer-events: all; /* But allow interaction with cells */
        }

        .cell {
            stroke: #fff;
            stroke-width: 0.5px;
            cursor: pointer;
            transition: fill 0.2s;
        }

        .cell:hover {
            opacity: 0.8;
        }

        .country-label {
            font-size: 8px; /* Smaller for irregular shapes */
            /* fill color set dynamically in JavaScript */
            stroke: none; /* Remove any outline/border */
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
        }
        
        .country-label.taiwan-label {
            font-size: 14px; /* Larger font for Taiwan */
        }
        
        .country-label.taiwan-label tspan {
            font-size: 14px !important; /* Override inline styles for Taiwan */
        }

        /* For the Taiwan outline itself */
        .taiwan-outline {
            fill: none;
            stroke: #333;
            stroke-width: 1.5px;
            stroke-linejoin: round;
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 16px;
        }

        .tooltip-content {
            font-size: 13px;
            line-height: 1.6;
        }

        /* Floating info boxes */
        .info-box {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 100;
            overflow-y: auto;
        }

        .info-box-large {
            width: 360px; /* 20% wider (300 * 1.2) */
            height: 400px;
            left: 20px;
            top: calc(50% - 200px); /* Center vertically without transform */
        }

        .info-box-medium {
            width: 600px;
            height: calc(47vh - 77px);
        }

        #info-box-top {
            right: 20px;
            top: 20px;
        }

        #info-box-bottom {
            right: 20px;
            bottom: 20px;
        }

        .info-box h3 {
            margin: 0 0 15px 0;
            color: #16476a;
            font-size: 18px;
            border-bottom: 2px solid #3b9797;
            padding-bottom: 10px;
            cursor: move;
            user-select: none;
        }

        .info-box.dragging {
            opacity: 0.8;
            z-index: 200;
        }

        .info-box p {
            margin: 10px 0;
            color: #333;
            font-size: 14px;
            line-height: 1.6;
        }
        
        /* Explosion marker styling */
        .explosion-marker {
            background: transparent;
            border: none;
            font-size: 24px;
            text-align: center;
            line-height: 30px;
        }
    </style>
</head>
<body>

<div class="headline">
    China's Attempts to Undermine Taiwan's Security
</div>

<div id="treemap-container">
    <div id="map"></div>
    <svg id="treemap-svg"></svg>
    <div id="tooltip" class="tooltip">
        <div class="tooltip-title"></div>
        <div class="tooltip-content"></div>
    </div>
    
    <!-- Floating info boxes -->
    <div class="info-box info-box-large">
        <h3>A. Foreign governments dissemination of false information over 10 years</h3>
        <p>Taiwan has ranked #1 in the world for the continuous 10 years in the foreign governments dissemination of false information.</p>
        <!-- Line chart will be inserted here -->
    </div>
    
    <div id="info-box-top" class="info-box info-box-medium">
        <h3>B. Daily harassment by china's military aircraft and ship</h3>
        <!-- Line chart will be inserted here -->
        <img src="military_map.png" alt="Military Map" style="width: 100%; height: auto; margin-top: 10px; border-radius: 5px;">
    </div>
    
    <div id="info-box-bottom" class="info-box info-box-medium">
        <h3>C. Submarine Cable cut by China's fishing boats</h3>
        <p>1. On January 3, 2025, a Cameroon-flagged cargo vessel ‚ÄúShunxin-39‚Äù was believed to have caused damage to an undersea cable of Taiwan</p>
        <p>2. On February 25, 2025,  a Tanzania-flagged vessel controlled by a Chinese entity, deliberately severed subsea cables near Keelung, disrupting Taiwan‚Äôs external communications. 
        <p>Between 2017 and 2023, the submarine cables between Taiwan and the Matsu Islands were cut by Chinese vessels 29 times.</p>
        <p>China has even invented a deep sea cable cutter for this purpose.</p>
    </div>
</div>

<!-- Load JavaScript libraries before our script -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        crossorigin=""></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="d3-weighted-voronoi.min.js"></script>
<script src="d3-voronoi-map.min.js"></script>
<script src="d3-voronoi-treemap.min.js"></script>

<script>
    let map;
    
    const data = [
        { Country: 'Taiwan', Score: -3.845, Size: 3.845, Category: 'Red', Rank: 1 },
        { Country: 'Portugal', Score: 2.859, Size: 2.859, Category: 'Green', Rank: 179 },
        { Country: 'Belarus', Score: -3.326, Size: 3.326, Category: 'Red', Rank: 2 },
        { Country: 'Malawi', Score: 2.645, Size: 2.645, Category: 'Green', Rank: 178 },
        { Country: 'Latvia', Score: -3.276, Size: 3.276, Category: 'Red', Rank: 3 },
        { Country: 'Trinidad and Tobago', Score: 2.606, Size: 2.606, Category: 'Green', Rank: 177 },
        { Country: 'Syria', Score: -2.630, Size: 2.630, Category: 'Red', Rank: 4},
        { Country: 'Switzerland', Score: 2.434, Size: 2.434, Category: 'Green', Rank: 176 },
        { Country: 'Kosovo', Score: -2.612, Size: 2.612, Category: 'Red', Rank: 5 },
        { Country: 'Seychelles', Score: 2.402, Size: 2.402, Category: 'Green', Rank: 175 }
    ];
    // CSV data for line chart
    const csvData = `country_name,year,v2smfordom
Switzerland,2015,2.434
Switzerland,2016,2.434
Switzerland,2017,2.434
Switzerland,2018,2.434
Switzerland,2019,2.434
Switzerland,2020,2.434
Switzerland,2021,2.434
Switzerland,2022,2.434
Switzerland,2023,2.434
Switzerland,2024,2.434
Portugal,2015,3.033
Portugal,2016,3.033
Portugal,2017,3.033
Portugal,2018,3.033
Portugal,2019,1.718
Portugal,2020,2.859
Portugal,2021,2.859
Portugal,2022,2.859
Portugal,2023,2.859
Portugal,2024,2.859
Kosovo,2015,-1.956
Kosovo,2016,-1.956
Kosovo,2017,-1.956
Kosovo,2018,-1.956
Kosovo,2019,-1.956
Kosovo,2020,-1.956
Kosovo,2021,-1.73
Kosovo,2022,-1.73
Kosovo,2023,-2.189
Kosovo,2024,-2.612
Taiwan,2015,-2.999
Taiwan,2016,-2.999
Taiwan,2017,-3.322
Taiwan,2018,-3.322
Taiwan,2019,-3.845
Taiwan,2020,-3.845
Taiwan,2021,-3.845
Taiwan,2022,-3.845
Taiwan,2023,-3.845
Taiwan,2024,-3.845
Latvia,2015,-2.769
Latvia,2016,-2.769
Latvia,2017,-2.769
Latvia,2018,-3.186
Latvia,2019,-3.186
Latvia,2020,-2.819
Latvia,2021,-2.819
Latvia,2022,-3.276
Latvia,2023,-3.276
Latvia,2024,-3.276
Malawi,2015,2.282
Malawi,2016,2.282
Malawi,2017,2.282
Malawi,2018,2.282
Malawi,2019,2.373
Malawi,2020,2.373
Malawi,2021,1.301
Malawi,2022,1.924
Malawi,2023,1.42
Malawi,2024,2.645
Syria,2015,-1.941
Syria,2016,-1.941
Syria,2017,-1.941
Syria,2018,-1.941
Syria,2019,-2.07
Syria,2020,-2.07
Syria,2021,-1.948
Syria,2022,-1.948
Syria,2023,-2.105
Syria,2024,-2.63
Belarus,2015,0.792
Belarus,2016,0.723
Belarus,2017,0.723
Belarus,2018,0.524
Belarus,2019,-0.323
Belarus,2020,-0.544
Belarus,2021,-2.157
Belarus,2022,-2.157
Belarus,2023,-2.157
Belarus,2024,-3.326
Trinidad and Tobago,2015,1.942
Trinidad and Tobago,2016,1.951
Trinidad and Tobago,2017,1.951
Trinidad and Tobago,2018,1.951
Trinidad and Tobago,2019,1.951
Trinidad and Tobago,2020,2.606
Trinidad and Tobago,2021,2.606
Trinidad and Tobago,2022,2.606
Trinidad and Tobago,2023,2.606
Trinidad and Tobago,2024,2.606
Seychelles,2015,0.723
Seychelles,2016,0.869
Seychelles,2017,0.869
Seychelles,2018,0.869
Seychelles,2019,0.869
Seychelles,2020,0.869
Seychelles,2021,0.869
Seychelles,2022,0.869
Seychelles,2023,1.475
Seychelles,2024,2.402`;

    // Parse CSV data
    const dataByYear = d3.csvParse(csvData, d => {
        return {
            country: d.country_name,
            year: +d.year,
            score: +d.v2smfordom
        };
    });
    
    // Create line chart
    function createLineChart() {
        // Find min and max values
        const minScore = d3.min(dataByYear, d => d.score);
        const maxScore = d3.max(dataByYear, d => d.score);
        
        // Chart dimensions (adjusted for large info box)
        const margin = { top: 20, right: 50, bottom: 40, left: 50 };
        const width = (250 * 1.2) - margin.left - margin.right; // 20% wider (300 - margins)
        const height = 300 - margin.top - margin.bottom;
        
        // Create SVG for line chart
        const chartContainer = d3.select(".info-box-large");
        chartContainer.select("svg").remove(); // Remove existing chart if any
        
        const svg = chartContainer.append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);
        
        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // X scale (years)
        const xScale = d3.scaleLinear()
            .domain([2015, 2024])
            .range([0, width]);
        
        // Y scale (inverted: most negative at top, most positive at bottom/0)
        const yScale = d3.scaleLinear()
            .domain([minScore, maxScore])
            .range([0, height]); // minScore at top (y=0), maxScore at bottom (y=height)
        
        // Line generator
        const line = d3.line()
            .x(d => xScale(d.year))
            .y(d => yScale(d.score))
            .curve(d3.curveMonotoneX);
        
        // Group data by country
        const countries = d3.group(dataByYear, d => d.country);
        
        // Color scale
        const colorScale = d3.scaleOrdinal()
            .domain(Array.from(countries.keys()))
            .range(d3.schemeCategory10);
        
        // Draw lines first
        const labelData = [];
        countries.forEach((values, country) => {
            const sortedValues = values.sort((a, b) => a.year - b.year);
            
            // Draw the line
            g.append("path")
                .datum(sortedValues)
                .attr("fill", "none")
                .attr("stroke", colorScale(country))
                .attr("stroke-width", country === "Taiwan" ? 3 : 1.5)
                .attr("d", line)
                .attr("opacity", country === "Taiwan" ? 1 : 0.7);
            
            // Store label data for collision detection
            const lastPoint = sortedValues[sortedValues.length - 1];
            labelData.push({
                country: country,
                x: xScale(lastPoint.year) + 5,
                y: yScale(lastPoint.score),
                color: colorScale(country),
                fontSize: country === "Taiwan" ? 11 : 9,
                fontWeight: country === "Taiwan" ? "bold" : "normal"
            });
        });
        
        // Sort labels by y-position to process from top to bottom
        labelData.sort((a, b) => a.y - b.y);
        
        // Collision detection and adjustment
        const minLabelSpacing = 12; // Minimum vertical spacing between labels
        const adjustedLabels = [];
        
        labelData.forEach((label, i) => {
            let adjustedY = label.y;
            
            // Check for collisions with previous labels
            for (let j = 0; j < adjustedLabels.length; j++) {
                const prevLabel = adjustedLabels[j];
                const distance = Math.abs(adjustedY - prevLabel.y);
                
                if (distance < minLabelSpacing) {
                    // If too close, move this label down
                    adjustedY = prevLabel.y + minLabelSpacing;
                }
            }
            
            adjustedLabels.push({
                ...label,
                y: adjustedY
            });
        });
        
        // Draw labels with adjusted positions
        adjustedLabels.forEach(label => {
            g.append("text")
                .attr("x", label.x)
                .attr("y", label.y)
                .attr("dy", "0.35em")
                .attr("fill", label.color)
                .style("font-size", label.fontSize + "px")
                .style("font-weight", label.fontWeight)
                .text(label.country);
        });
        
        // Add X axis
        const xAxis = d3.axisBottom(xScale)
            .tickFormat(d3.format("d"))
            .ticks(10);
        
        const xAxisGroup = g.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(xAxis);
        
        // Rotate year labels 45 degrees
        xAxisGroup.selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-0.5em")
            .attr("dy", "0.5em")
            .attr("transform", "rotate(-45)");
        
        // Add axis label
        xAxisGroup.append("text")
            .attr("x", width / 2)
            .attr("y", 35)
            .attr("fill", "black")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Year");
        
        // Add Y axis (inverted)
        const yAxis = d3.axisLeft(yScale)
            .ticks(8);
        
        g.append("g")
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -40)
            .attr("x", -height / 2)
            .attr("fill", "black")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Score");
        
        // Add label at bottom (y=height position) showing max value - moved lower
        g.append("text")
            .attr("x", width + 5)
            .attr("y", height + 15) // Moved lower to avoid covering country names
            .attr("fill", "black")
            .style("text-anchor", "start")
            .style("font-size", "10px")
            .style("font-weight", "bold")
            .text(maxScore.toFixed(3));
        
        // Add label at top (y=0 position) showing min value - moved higher
        g.append("text")
            .attr("x", width + 5)
            .attr("y", -5) // Moved higher to avoid covering country names
            .attr("dy", "0.35em")
            .attr("fill", "black")
            .style("text-anchor", "start")
            .style("font-size", "10px")
            .style("font-weight", "bold")
            .text(minScore.toFixed(3));
    }
    
    // Initialize line chart when page loads
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', createLineChart);
    } else {
        createLineChart();
    }
    
    const svg = d3.select("#treemap-svg");
    
    // Initialize Leaflet map (free, no API key needed!)
    function initMap() {
        console.log('=== INIT MAP CALLED ===');
        console.log('Leaflet available:', typeof L !== 'undefined');
        console.log('Map element:', document.getElementById('map'));
        
        try {
            // Check if Leaflet is loaded
            if (typeof L === 'undefined') {
                console.error('Leaflet library not loaded. Retrying in 200ms...');
                setTimeout(initMap, 200);
                return;
            }
            
            const mapElement = document.getElementById('map');
            if (!mapElement) {
                console.error('Map element not found!');
                return;
            }
            
            // Check if map element has dimensions
            const rect = mapElement.getBoundingClientRect();
            console.log('Map element dimensions:', rect.width, 'x', rect.height);
            console.log('Map element styles:', window.getComputedStyle(mapElement).height);
            
            // Center on Taiwan
            const taiwanCenter = [23.5, 121.0];
            
            // Initialize Leaflet map with OpenStreetMap tiles (free!)
            console.log('Creating Leaflet map...');
            map = L.map('map', {
                center: taiwanCenter,
                zoom: 7,
                zoomControl: true
            });
            
            console.log('Map created, adding tile layer...');
            
            // Add CartoDB Positron tile layer (cleaner, no administrative boundaries)
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors ¬© <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
            
            console.log('Tile layer added. Map should be visible now!');
            
            // Load and add cables GeoJSON layer
            fetch('cables.geojson')
                .then(response => response.json())
                .then(cablesData => {
                    console.log('Cables GeoJSON loaded:', cablesData);
                    
                    // Add cables as a GeoJSON layer
                    const cablesLayer = L.geoJSON(cablesData, {
                        style: function(feature) {
                            return {
                                color: '#ff6b6b', // Red color for cables
                                weight: 2,
                                opacity: 0.8
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            // Add popup with cable information if available
                            if (feature.properties) {
                                const props = feature.properties;
                                let popupContent = '<div style="font-size: 12px;">';
                                if (props.name) popupContent += `<strong>${props.name}</strong><br>`;
                                if (props.owner) popupContent += `Owner: ${props.owner}<br>`;
                                if (props.length) popupContent += `Length: ${props.length}<br>`;
                                popupContent += '</div>';
                                layer.bindPopup(popupContent);
                            }
                            
                            // Add explosion emoji markers at specific locations for each LineString
                            if (feature.geometry && feature.geometry.type === 'LineString') {
                                // Get the index of this feature to determine which marker to use
                                const featureIndex = cablesData.features.indexOf(feature);
                                
                                // Define specific coordinates for each LineString
                                const markerCoords = [
                                    [25.336203855785385, 121.4801793349356], // First LineString
                                    [23.265354792178385, 120.0130222302808]  // Second LineString
                                ];
                                
                                // Add explosion emoji at the specified location
                                if (markerCoords[featureIndex]) {
                                    const marker = L.marker(markerCoords[featureIndex], {
                                        icon: L.divIcon({
                                            className: 'explosion-marker',
                                            html: 'üí•',
                                            iconSize: [30, 30],
                                            iconAnchor: [15, 15]
                                        })
                                    }).addTo(map);
                                    
                                    console.log('Added explosion marker at:', markerCoords[featureIndex]);
                                }
                            }
                        }
                    }).addTo(map);
                    
                    console.log('Cables layer added to map');
                })
                .catch(error => {
                    console.error('Error loading cables.geojson:', error);
                });
            
            // Force map to invalidate size in case of layout issues
            setTimeout(function() {
                console.log('Invalidating map size...');
                map.invalidateSize();
            }, 200);
            
            // Load GeoJSON and draw treemap after map is ready
            map.whenReady(function() {
                console.log('Map is ready, checking for GeoJSON data...');
                console.log('geojsonData available:', !!geojsonData);
                
                if (geojsonData) {
                    console.log('Drawing treemap with existing GeoJSON data...');
                    drawTreemap(geojsonData);
                } else {
                    console.log('GeoJSON not loaded yet, will draw when it loads');
                }
            });
            
            // Redraw treemap on zoom and pan
            map.on('moveend', function() {
                if (geojsonData) {
                    drawTreemap(geojsonData);
                }
            });
            
            map.on('zoomend', function() {
                if (geojsonData) {
                    drawTreemap(geojsonData);
                }
            });
        } catch (error) {
            console.error('Error initializing map:', error);
            console.error('Error stack:', error.stack);
            const mapElement = document.getElementById('map');
            if (mapElement) {
                mapElement.innerHTML = '<div style="padding: 20px; text-align: center; color: red; background: white; z-index: 1000;">Error: ' + error.message + '<br>Check console for details.</div>';
            }
        }
    }
    
    // Wait for DOM and scripts to be ready
    function startInit() {
        console.log('=== STARTING INITIALIZATION ===');
        console.log('Document ready state:', document.readyState);
        console.log('Leaflet loaded:', typeof L !== 'undefined');
        console.log('Map div exists:', !!document.getElementById('map'));
        
        if (typeof L === 'undefined') {
            console.log('Leaflet not loaded yet, waiting...');
            setTimeout(startInit, 100);
            return;
        }
        
        if (!document.getElementById('map')) {
            console.log('Map div not found yet, waiting...');
            setTimeout(startInit, 100);
            return;
        }
        
        initMap();
    }
    
    // Start initialization
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startInit);
    } else {
        // DOM already loaded, but wait a bit for scripts
        setTimeout(startInit, 100);
    }
    
    // --- 1. Define Color Scales ---
    const colorRed = d3.scaleLinear()
        .domain([-3.845, -2.612]) // Min and Max negative scores
        .range(["#000000", "#1d81a2"]); // Deep Red to Light Red
    
    const colorGreen = d3.scaleLinear()
        .domain([2.402, 2.859]) // Min and Max positive scores
        .range(["#398564", "#fdfff5"]); // Light Green to Bright Green
    
    const getColor = (d) => {
        if (d.data.Category === 'Red') {
            return colorRed(d.data.Score);
        } else {
            return colorGreen(d.data.Score);
        }
    };
    
    // Find darkest blocks for text color determination
    const redScores = data.filter(d => d.Category === 'Red').map(d => d.Score);
    const greenScores = data.filter(d => d.Category === 'Green').map(d => d.Score);
    const darkestRed = Math.min(...redScores); // Most negative (darkest)
    const darkestGreen = Math.max(...greenScores); // Most positive (darkest)
    
    const getTextColor = (d) => {
        if (d.data.Category === 'Red') {
            return 'white'; // Darkest red block
        }  else {
            return 'black'; // All other blocks
        }
    };
    
    // Function to project lat/lng to pixel coordinates using Leaflet projection
    function projectLatLngToPixel(lat, lng) {
        if (!map) return null;
        
        // Leaflet's latLngToContainerPoint converts lat/lng to pixel coordinates
        const point = map.latLngToContainerPoint([lat, lng]);
        
        return [point.x, point.y];
    }
    
    // Function to draw/redraw the treemap
    function drawTreemap(geojson) {
        console.log('=== DRAWING TREEMAP ===');
        console.log('SVG element:', svg.node());
        console.log('SVG current content children:', svg.node() ? svg.node().children.length : 'no node');
        
        // Clear existing content (but keep test circle for now)
        const beforeClear = svg.node() ? svg.node().children.length : 0;
        console.log('SVG children before clear:', beforeClear);
        svg.selectAll("g, path, defs").remove();
        const afterClear = svg.node() ? svg.node().children.length : 0;
        console.log('SVG children after clear:', afterClear);
        
        // Get current dimensions
        const containerRect = document.getElementById("treemap-container").getBoundingClientRect();
        const width = containerRect.width;
        const height = containerRect.height;
        
        console.log('Container dimensions:', width, 'x', height);
        
        // Set SVG dimensions
        svg.attr("width", width).attr("height", height);
        
        if (!geojson || !geojson.features || geojson.features.length === 0) {
            console.error("Failed to load or parse taiwan.geojson, or it's empty.");
            return;
        }
        
        if (!map) {
            console.log("Map not ready yet, will retry...");
            return;
        }
        
        console.log('GeoJSON features:', geojson.features.length);
    
        // Assuming the GeoJSON contains one main feature for Taiwan
        const taiwanFeature = geojson.features[0];
    
        // Project coordinates using Leaflet projection
        function projectCoordinates(coords) {
            if (Array.isArray(coords[0])) {
                return coords.map(projectCoordinates);
            }
            // coords is [lng, lat] in GeoJSON format
            const pixel = projectLatLngToPixel(coords[1], coords[0]);
            return pixel || [0, 0];
        }
        
        // Get the geometry and project it
        const geometry = taiwanFeature.geometry;
        let outerRing;
        
        if (geometry.type === 'Polygon') {
            outerRing = geometry.coordinates[0];
        } else if (geometry.type === 'MultiPolygon') {
            outerRing = geometry.coordinates[0][0]; // First polygon, outer ring
        } else {
            console.error('Unsupported geometry type:', geometry.type);
            return;
        }
        
        const projectedPoints = outerRing.map(coord => projectCoordinates(coord));
        
        console.log('Projected points sample (first 3):', projectedPoints.slice(0, 3));
        
        // Filter out invalid points (points that are null or [0, 0])
        const validPoints = projectedPoints.filter(p => p && (p[0] !== 0 || p[1] !== 0));
        
        console.log('Valid points:', validPoints.length, 'out of', projectedPoints.length);
        
        if (validPoints.length === 0) {
            console.error("No valid projected points");
            return;
        }
        
        // Close the path if needed
        if (validPoints.length > 0 && 
            (validPoints[0][0] !== validPoints[validPoints.length - 1][0] ||
             validPoints[0][1] !== validPoints[validPoints.length - 1][1])) {
            validPoints.push(validPoints[0]);
        }
        
        // Create path data for Taiwan outline
        const taiwanPathData = "M" + validPoints.map(p => `${p[0]},${p[1]}`).join("L") + "Z";
        
        console.log('Taiwan path created, length:', taiwanPathData.length);
    
        // Define a clip path for the Taiwan shape
        console.log('Creating clip path...');
        const defs = svg.append("defs");
        const clipPath = defs.append("clipPath")
            .attr("id", "taiwan-clip");
        clipPath.append("path")
            .attr("d", taiwanPathData);
        console.log('Clip path created');
    
        // Taiwan outline removed - the map already shows Taiwan's boundaries
    
        // --- 3. Prepare Data for Voronoi Treemap ---
        const root = d3.hierarchy({ children: data })
            .sum(d => d.Size)
            .sort((a, b) => b.value - a.value);
    
        // --- 4. Initialize the Voronoi Treemap Layout ---
        if (typeof d3.voronoiTreemap === 'undefined') {
            console.error('d3-voronoi-treemap library not loaded!');
            return;
        }
    
        const voronoiTreemap = d3.voronoiTreemap()
            .clip(validPoints.slice(0, -1)); // Remove the closing point for clipping
    
        try {
            console.log('Computing voronoi treemap...');
            voronoiTreemap(root);
            console.log('Voronoi treemap computed successfully');
        } catch (error) {
            console.error('Error computing treemap:', error);
            console.error('Error stack:', error.stack);
            return;
        }
    
        // --- 6. Drawing the Cells (Polygons) ---
        console.log('Creating cells group...');
        const cellsGroup = svg.append("g")
            .attr("clip-path", "url(#taiwan-clip)");
        console.log('Cells group created:', cellsGroup.node());
    
        const leaves = root.leaves();
        console.log('Number of leaves (cells) to draw:', leaves.length);
        console.log('Sample leaf data:', leaves[0] ? {
            country: leaves[0].data.Country,
            hasPolygon: !!leaves[0].polygon,
            polygonLength: leaves[0].polygon ? leaves[0].polygon.length : 0
        } : 'no leaves');
        
        const cell = cellsGroup.selectAll(".cell")
            .data(leaves)
            .enter().append("g")
            .attr("class", "cell");
        
        console.log('Cell groups created:', cell.size());
    
        // Create tooltip element
        const tooltip = d3.select("#tooltip");
        
        console.log('Appending paths to cells...');
        const paths = cell.append("path")
            .attr("d", d => {
                if (!d.polygon || d.polygon.length === 0) {
                    console.warn('Cell has no polygon:', d.data.Country);
                    return null;
                }
                const pathData = "M" + d.polygon.map(p => `${p[0]},${p[1]}`).join("L") + "Z";
                return pathData;
            })
            .attr("fill", d => getColor(d))
            .on("mouseover", function(event, d) {
                // Show tooltip
                tooltip.select(".tooltip-title")
                    .text(d.data.Country);
                
                // Get rank (handle both "Rank" and "rank" cases)
                const rank = d.data.Rank || d.data.rank;
                
                tooltip.select(".tooltip-content")
                    .html(`Rank: ${rank}<br>` +
                          `Score: ${d.data.Score.toFixed(3)}<br>` +
                          `Category: ${d.data.Category}<br>` +
                          `Size: ${d.data.Size.toFixed(3)}`);
                
                tooltip.classed("visible", true);
            })
            .on("mouseout", function() {
                // Hide tooltip
                tooltip.classed("visible", false);
            })
            .on("mousemove", function(event) {
                // Follow mouse cursor
                const containerRect = document.getElementById("treemap-container").getBoundingClientRect();
                const tooltipNode = tooltip.node();
                const tooltipWidth = tooltipNode.offsetWidth || 150;
                const tooltipHeight = tooltipNode.offsetHeight || 80;
                
                // Position tooltip near cursor, offset to avoid covering the cursor
                let left = event.pageX - containerRect.left + 15;
                let top = event.pageY - containerRect.top - tooltipHeight - 10;
                
                // Keep tooltip within container bounds
                if (left + tooltipWidth > containerRect.width) {
                    left = event.pageX - containerRect.left - tooltipWidth - 15;
                }
                if (top < 0) {
                    top = event.pageY - containerRect.top + 15;
                }
                
                tooltip
                    .style("left", `${left}px`)
                    .style("top", `${top}px`);
            });
        
        console.log('Cells drawn:', cell.size());
    
        // --- 7. Add Labels (UPDATED LOGIC) ---
        cell.append("text")
            .attr("class", d => {
                // Add special class for Taiwan
                return d.data.Country === 'Taiwan' ? "country-label taiwan-label" : "country-label";
            })
            .attr("transform", d => `translate(${d3.polygonCentroid(d.polygon)})`) // Position at centroid
            .style("fill", d => getTextColor(d)) // Set text color based on block darkness
            .style("stroke", "none") // Explicitly remove stroke/outline
            .selectAll("tspan")
            .data(d => {
                // Data array to hold both the Country Name and the Score
                const labels = [];
                
                // 1. Country Name (can be shortened for small cells)
                const name = d.data.Country;
                const isTaiwan = name === 'Taiwan';
                if (!isTaiwan && d.value / root.value < 0.05) { // Heuristic: If cell is very small, use abbreviation
                    labels.push(name.substring(0, 3) + '.');
                } else {
                    labels.push(name);
                }
                
                // 2. Score Value
                labels.push(d.data.Score.toFixed(3)); 
                
                return labels;
            })
            .enter().append("tspan")
            .attr("x", 0) // Centered
            .attr("dy", (d, i) => { 
                 // First line (Country Name) is slightly above center
                 if (i === 0) return "-0.5em";
                 // Second line (Score Value) is on the baseline
                 return "1.2em"; 
            })
            .style("font-size", function(d, i) {
                // Check if parent text has taiwan-label class
                const isTaiwan = d3.select(this.parentNode).classed("taiwan-label");
                if (isTaiwan) {
                    return i === 1 ? "12px" : "14px"; // Larger font for Taiwan
                }
                return i === 1 ? "7px" : "8px"; // Normal size for others
            })
            .style("font-weight", (d, i) => i === 1 ? "normal" : "bold") // Country name bold
            .text(d => d);
    
        // Taiwan outline removed
    }
    
    // --- 2. Load Taiwan GeoJSON and draw treemap ---
    let geojsonData = null;
    d3.json("taiwan.geojson").then(function(geojson) {
        console.log('GeoJSON loaded successfully');
        console.log('GeoJSON features:', geojson.features ? geojson.features.length : 'none');
        geojsonData = geojson;
        // Draw treemap if map is already initialized
        if (map) {
            console.log('Map is ready, drawing treemap...');
            // Small delay to ensure map is fully rendered
            setTimeout(function() {
                drawTreemap(geojson);
            }, 300);
        } else {
            console.log('Map not ready yet, treemap will be drawn when map loads');
        }
    }).catch(function(error) {
        console.error("Error loading GeoJSON or creating treemap:", error);
        console.error("Error details:", error);
    });
    
    // Handle window resize with debouncing
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            if (geojsonData && map) {
                drawTreemap(geojsonData);
            }
        }, 250); // Wait 250ms after resize stops
    });
    
    // Make info boxes draggable
    function makeDraggable(element) {
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;
        
        const container = document.getElementById("treemap-container");
        const header = element.querySelector('h3');
        
        header.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        
        function dragStart(e) {
            if (e.button !== 0) return; // Only left mouse button
            
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
            
            if (e.target === header || header.contains(e.target)) {
                isDragging = true;
                element.classList.add('dragging');
                
                // Get current position
                const rect = element.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                xOffset = rect.left - containerRect.left;
                yOffset = rect.top - containerRect.top;
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
        }
        
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                
                xOffset = currentX;
                yOffset = currentY;
                
                // Get container bounds
                const containerRect = container.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                // Constrain to container bounds
                const minX = 0;
                const minY = 0;
                const maxX = containerRect.width - elementRect.width;
                const maxY = containerRect.height - elementRect.height;
                
                xOffset = Math.max(minX, Math.min(maxX, xOffset));
                yOffset = Math.max(minY, Math.min(maxY, yOffset));
                
                // Remove right/bottom positioning and use left/top
                element.style.right = 'auto';
                element.style.bottom = 'auto';
                element.style.left = xOffset + 'px';
                element.style.top = yOffset + 'px';
            }
        }
        
        function dragEnd(e) {
            if (isDragging) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
                element.classList.remove('dragging');
            }
        }
    }
    
    // Initialize dragging for all info boxes
    function initDraggableBoxes() {
        const infoBoxes = document.querySelectorAll('.info-box');
        infoBoxes.forEach(box => {
            makeDraggable(box);
        });
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDraggableBoxes);
    } else {
        initDraggableBoxes();
    }
    
    </script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <title>Taiwan Voronoi Treemap</title>
    <!-- Google Fonts - Noto Sans TC for Traditional Chinese support -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          crossorigin=""/>
    <style>
        body { 
            margin: 0; 
            overflow-x: hidden; 
            overflow-y: auto; 
            font-family: 'Noto Sans TC', sans-serif;
            background: #f5f5f5;
        }
        
        .headline {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, #16476a 0%, #3b9797 100%);
            color: white;
            font-size: 2.5rem;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            letter-spacing: 1px;
        }
        
        #treemap-container {
            position: relative; /* Needed for tooltip positioning */
            width: 100%;
            height: 85vh;
            min-height: 700px;
            margin: 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #map {
            width: 100%;
            height: 100%;
            z-index: 0; /* Ensure map is behind SVG overlay */
            min-height: 400px; /* Ensure map has minimum height */
            background-color: #e0e0e0; /* Temporary background to see if div exists */
        }
        
        /* Leaflet map container styles */
        .leaflet-container {
            background: #f0f0f0;
            height: 100% !important;
            width: 100% !important;
        }

        #treemap-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow map interaction to pass through */
            z-index: 100; /* Ensure SVG is above the map */
            background: transparent; /* Make sure it's transparent, not blocking */
        }

        #treemap-svg .cell {
            pointer-events: all; /* But allow interaction with cells */
        }

        .cell {
            stroke: #fff;
            stroke-width: 0.5px;
            cursor: pointer;
            transition: fill 0.2s;
        }

        .cell:hover {
            opacity: 0.8;
        }

        .country-label {
            font-size: 8px; /* Smaller for irregular shapes */
            /* fill color set dynamically in JavaScript */
            stroke: none; /* Remove any outline/border */
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
        }
        
        .country-label.taiwan-label {
            font-size: 14px; /* Larger font for Taiwan */
        }
        
        .country-label.taiwan-label tspan {
            font-size: 14px !important; /* Override inline styles for Taiwan */
        }

        /* For the Taiwan outline itself */
        .taiwan-outline {
            fill: none;
            stroke: #333;
            stroke-width: 1.5px;
            stroke-linejoin: round;
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 16px;
        }

        .tooltip-content {
            font-size: 13px;
            line-height: 1.6;
        }

        /* Floating info boxes */
        .info-box {
            position: absolute;
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 100;
            overflow: hidden;
            min-width: 200px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            border: 2px solid #e8e8e8;
        }
        
        .info-box-content {
            flex: 1;
            overflow-y: auto;
            padding: 25px;
            padding-top: 15px;
            background: #fafafa;
        }
        
        .info-box p {
            margin: 12px 0;
            color: #333;
            font-size: 14px;
            line-height: 1.7;
        }
        
        /* Resize handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            background: linear-gradient(-45deg, transparent 30%, #ccc 30%, #ccc 35%, transparent 35%, transparent 65%, #ccc 65%, #ccc 70%, transparent 70%);
            border-bottom-right-radius: 10px;
            z-index: 101;
        }
        
        .resize-handle:hover {
            background: linear-gradient(-45deg, transparent 30%, #999 30%, #999 35%, transparent 35%, transparent 65%, #999 65%, #999 70%, transparent 70%);
        }
        
        .info-box.resizing {
            user-select: none;
        }

        .info-box-large {
            width: 690px; /* 20% wider (300 * 1.2) */
            height: 662px;
            left: 0;
            top: 0; /* Center vertically without transform */
        }

        .info-box-medium {
            width: 600px;
            height: calc(47vh - 77px);
        }

        /* Section styling for B and C info boxes */
        .sections-container {
            width: 100%;
            max-width: 1400px;
            margin: 50px auto;
            padding: 0 40px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 40px;
        }
        
        .content-section {
            width: 100%;
        }
        
        .section-info-box {
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
            min-width: 200px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            height: 100%;
            border: 1px solid #e0e0e0;
            overflow: hidden;
        }
        
        .section-info-box h3 {
            margin: 0;
            color: white;
            font-size: 20px;
            background: linear-gradient(135deg, #16476a 0%, #3b9797 100%);
            padding: 25px 30px;
            user-select: none;
            position: relative;
            z-index: 1;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .section-info-box .info-box-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            padding-top: 20px;
            background: #fafafa;
        }
        
        .chart-image-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
            margin-top: 20px;
        }
        
        .chart-image-container img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .image-caption {
            margin-top: 8px;
            font-size: 11px;
            color: #666;
            font-style: italic;
            text-align: center;
        }
        
        .image-caption-top {
            margin-bottom: 10px;
            font-size: 12px;
            color: #555;
            font-weight: 500;
            text-align: center;
        }
        
        .chart-caption {
            margin-bottom: 15px;
            font-size: 13px;
            color: #555;
            font-weight: 500;
            text-align: center;
        }
        
        .image-caption a {
            color: #3b9797;
            text-decoration: none;
        }
        
        .image-caption a:hover {
            text-decoration: underline;
        }
        
        /* Modal for enlarged images */
        .image-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            cursor: pointer;
        }
        
        .image-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .image-modal-content {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .image-modal-close {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10001;
        }
        
        .image-modal-close:hover {
            color: #ccc;
        }
        
        .enlargeable-image {
            cursor: pointer;
            transition: opacity 0.3s;
        }
        
        .enlargeable-image:hover {
            opacity: 0.9;
        }
        
        .chart-image-container .military-chart {
            width: 100%;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        @media (max-width: 900px) {
            .chart-image-container {
                grid-template-columns: 1fr;
            }
        }
        
        #info-box-top {
            right: 20px;
            top: 20px;
        }

        #info-box-bottom {
            right: 20px;
            bottom: 20px;
        }

        .info-box h3 {
            margin: 0;
            color: white;
            font-size: 18px;
            background: linear-gradient(135deg, #16476a 0%, #3b9797 100%);
            padding: 20px 20px 15px 20px;
            cursor: move;
            user-select: none;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .info-box.dragging {
            opacity: 0.8;
            z-index: 200;
        }

        .info-box p {
            margin: 10px 0;
            color: #333;
            font-size: 14px;
            line-height: 1.6;
        }
        
        /* Explosion marker styling */
        .explosion-marker {
            background: transparent;
            border: none;
            font-size: 24px;
            text-align: center;
            line-height: 30px;
        }
    </style>
</head>
<body>

<div class="headline">
    China's Attempts to Undermine Taiwan's Security
</div>

<div id="treemap-container">
    <div id="map"></div>
    <svg id="treemap-svg"></svg>
    <div id="tooltip" class="tooltip">
        <div class="tooltip-title"></div>
        <div class="tooltip-content"></div>
    </div>
    
    <!-- Floating info boxes -->
    <div class="info-box info-box-large">
        <h3>A. Foreign governments dissemination of false information over 10 years</h3>
        <div class="info-box-content">
            <p>Taiwan has ranked #1 in the world for the continuous 10 years in the foreign governments dissemination of false information.</p>
            <!-- Line chart will be inserted here -->
        </div>
        <div class="resize-handle"></div>
    </div>
    
    <div id="info-box-bottom" class="info-box info-box-medium">
        <h3>B. Submarine Cables cut by China's fishing boats</h3>
        <div class="info-box-content">
            <p>ðŸ’¥<span style="font-size: 14px; font-weight: bold; color: #000; background: rgba(255,255,255,0.8); padding: 2px 4px; border-radius: 3px;">1</span> On January 3, 2025,  a Tanzania-flagged vessel while registered in Cameroon called Shunxin-39, controlled by a Chinese entity, deliberately severed subsea cables near Keelung, disrupting Taiwan's external communications.</p>
            <p>ðŸ’¥<span style="font-size: 14px; font-weight: bold; color: #000; background: rgba(255,255,255,0.8); padding: 2px 4px; border-radius: 3px;">2</span> On February 25, 2025,  a Togolese-registered cargo vessel that severed a submarine communication cable between Taiwan and Penghu.</p> 
            <p>â€¢ Between 2017 and 2023, the submarine cables between Taiwan and the Matsu Islands were cut by Chinese vessels 29 times.</p>
            <p>â€¢ China has even invented a deep sea cable cutter for this purpose.</p>
            <img src="cable_cutter.jpeg" alt="Deep sea cable cutter" class="enlargeable-image" style="width: 100%; height: auto; margin-top: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" onclick="openImageModal(this.src)">
        </div>
        <div class="resize-handle"></div>
    </div>
</div>

<!-- Section B -->
<div class="sections-container">
    <section class="content-section">
        <div class="section-info-box">
            <h3>C. PLA (People's Liberation Army) air activities in the vicinity of Taiwan over the past 30 days</h3>
            <div class="info-box-content">
                <p style="margin-bottom: 20px; color: #555; font-size: 13px; line-height: 1.6;">30 days activities gathered from Ministry of National Defense of Taiwan. Mapping all the aircrafts, drones, helicopters, naval ships.</p>
                <p style="margin-bottom: 20px; color: #8080c0; font-size: 13px; line-height: 1.6; font-weight: 600; padding: 12px; background: #f0f0f8; border-left: 4px solid #8080c0; border-radius: 4px;"><strong>Fun fact:</strong> The only day that they didn't send any aircrafts or ships to Taiwan strait is the day when there was a typhoon on 11/11/2025.</p>
                <div class="chart-image-container">
                    <div>
                        <p class="image-caption-top">Images gathered and mapped to see all the trajectories by PLA using Maximum Difference Projection</p>
                        <img src="military_map.png" alt="Military Map" style="width: 100%; height: auto; margin-top: 10px; border-radius: 5px;">
                        <p class="image-caption">Source: <a href="https://www.mnd.gov.tw/PublishTable.aspx?Types=%E5%8D%B3%E6%99%82%E8%BB%8D%E4%BA%8B%E5%8B%95%E6%85%8B&title=%E5%9C%8B%E9%98%B2%E6%B6%88%E6%81%AF" target="_blank">Ministry of National Defense, R.O.C.</a></p>
                    </div>
                    <div>
                        <p class="chart-caption">Trends of military activities categorized by aircrafts and vessals over the past 30 days</p>
                        <div class="military-chart"></div>
                    </div>
                </div>
            </div>
        </div>
    </section>
</div>

<!-- Load JavaScript libraries before our script -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        crossorigin=""></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="d3-weighted-voronoi.min.js"></script>
<script src="d3-voronoi-map.min.js"></script>
<script src="d3-voronoi-treemap.min.js"></script>

<script>
    let map;
    
    const data = [
        { Country: 'Taiwan', Score: -3.845, Size: 3.845, Category: 'Red', Rank: 1 },
        { Country: 'Portugal', Score: 2.859, Size: 2.859, Category: 'Green', Rank: 179 },
        { Country: 'Belarus', Score: -3.326, Size: 3.326, Category: 'Red', Rank: 2 },
        { Country: 'Malawi', Score: 2.645, Size: 2.645, Category: 'Green', Rank: 178 },
        { Country: 'Latvia', Score: -3.276, Size: 3.276, Category: 'Red', Rank: 3 },
        { Country: 'Trinidad and Tobago', Score: 2.606, Size: 2.606, Category: 'Green', Rank: 177 },
        { Country: 'Syria', Score: -2.630, Size: 2.630, Category: 'Red', Rank: 4},
        { Country: 'Switzerland', Score: 2.434, Size: 2.434, Category: 'Green', Rank: 176 },
        { Country: 'Kosovo', Score: -2.612, Size: 2.612, Category: 'Red', Rank: 5 },
        { Country: 'Seychelles', Score: 2.402, Size: 2.402, Category: 'Green', Rank: 175 }
    ];
    // CSV data for line chart
    const csvData = `country_name,year,v2smfordom
Switzerland,2015,2.434
Switzerland,2016,2.434
Switzerland,2017,2.434
Switzerland,2018,2.434
Switzerland,2019,2.434
Switzerland,2020,2.434
Switzerland,2021,2.434
Switzerland,2022,2.434
Switzerland,2023,2.434
Switzerland,2024,2.434
Portugal,2015,3.033
Portugal,2016,3.033
Portugal,2017,3.033
Portugal,2018,3.033
Portugal,2019,1.718
Portugal,2020,2.859
Portugal,2021,2.859
Portugal,2022,2.859
Portugal,2023,2.859
Portugal,2024,2.859
Kosovo,2015,-1.956
Kosovo,2016,-1.956
Kosovo,2017,-1.956
Kosovo,2018,-1.956
Kosovo,2019,-1.956
Kosovo,2020,-1.956
Kosovo,2021,-1.73
Kosovo,2022,-1.73
Kosovo,2023,-2.189
Kosovo,2024,-2.612
Taiwan,2015,-2.999
Taiwan,2016,-2.999
Taiwan,2017,-3.322
Taiwan,2018,-3.322
Taiwan,2019,-3.845
Taiwan,2020,-3.845
Taiwan,2021,-3.845
Taiwan,2022,-3.845
Taiwan,2023,-3.845
Taiwan,2024,-3.845
Latvia,2015,-2.769
Latvia,2016,-2.769
Latvia,2017,-2.769
Latvia,2018,-3.186
Latvia,2019,-3.186
Latvia,2020,-2.819
Latvia,2021,-2.819
Latvia,2022,-3.276
Latvia,2023,-3.276
Latvia,2024,-3.276
Malawi,2015,2.282
Malawi,2016,2.282
Malawi,2017,2.282
Malawi,2018,2.282
Malawi,2019,2.373
Malawi,2020,2.373
Malawi,2021,1.301
Malawi,2022,1.924
Malawi,2023,1.42
Malawi,2024,2.645
Syria,2015,-1.941
Syria,2016,-1.941
Syria,2017,-1.941
Syria,2018,-1.941
Syria,2019,-2.07
Syria,2020,-2.07
Syria,2021,-1.948
Syria,2022,-1.948
Syria,2023,-2.105
Syria,2024,-2.63
Belarus,2015,0.792
Belarus,2016,0.723
Belarus,2017,0.723
Belarus,2018,0.524
Belarus,2019,-0.323
Belarus,2020,-0.544
Belarus,2021,-2.157
Belarus,2022,-2.157
Belarus,2023,-2.157
Belarus,2024,-3.326
Trinidad and Tobago,2015,1.942
Trinidad and Tobago,2016,1.951
Trinidad and Tobago,2017,1.951
Trinidad and Tobago,2018,1.951
Trinidad and Tobago,2019,1.951
Trinidad and Tobago,2020,2.606
Trinidad and Tobago,2021,2.606
Trinidad and Tobago,2022,2.606
Trinidad and Tobago,2023,2.606
Trinidad and Tobago,2024,2.606
Seychelles,2015,0.723
Seychelles,2016,0.869
Seychelles,2017,0.869
Seychelles,2018,0.869
Seychelles,2019,0.869
Seychelles,2020,0.869
Seychelles,2021,0.869
Seychelles,2022,0.869
Seychelles,2023,1.475
Seychelles,2024,2.402`;

    // Parse CSV data
    const dataByYear = d3.csvParse(csvData, d => {
        return {
            country: d.country_name,
            year: +d.year,
            score: +d.v2smfordom
        };
    });
    
    // Create line chart
    function createLineChart() {
        // Find min and max values
        const minScore = d3.min(dataByYear, d => d.score);
        const maxScore = d3.max(dataByYear, d => d.score);
        
        // Chart dimensions (adjusted for large info box - 690px Ã— 662px, 85% width, 80% height)
        const margin = { top: 20, right: 50, bottom: 40, left: 50 };
        const width = (690 * 0.85) - margin.left - margin.right; // 85% of container width minus margins
        const height = (662 * 0.80) - margin.top - margin.bottom; // 80% of container height minus margins (5% shorter)
        
        // Create SVG for line chart
        const chartContainer = d3.select(".info-box-large .info-box-content");
        chartContainer.select("svg").remove(); // Remove existing chart if any
        
        const svg = chartContainer.append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);
        
        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // X scale (years)
        const xScale = d3.scaleLinear()
            .domain([2015, 2024])
            .range([0, width]);
        
        // Y scale (inverted: most negative at top, most positive at bottom/0)
        const yScale = d3.scaleLinear()
            .domain([minScore, maxScore])
            .range([0, height]); // minScore at top (y=0), maxScore at bottom (y=height)
        
        // Line generator
        const line = d3.line()
            .x(d => xScale(d.year))
            .y(d => yScale(d.score))
            .curve(d3.curveMonotoneX);
        
        // Group data by country
        const countries = d3.group(dataByYear, d => d.country);
        
        // Color scale
        const colorScale = d3.scaleOrdinal()
            .domain(Array.from(countries.keys()))
            .range(d3.schemeCategory10);
        
        // Draw lines first
        const labelData = [];
        countries.forEach((values, country) => {
            const sortedValues = values.sort((a, b) => a.year - b.year);
            
            // Draw the line
            g.append("path")
                .datum(sortedValues)
                .attr("fill", "none")
                .attr("stroke", colorScale(country))
                .attr("stroke-width", country === "Taiwan" ? 3 : 1.5)
                .attr("d", line)
                .attr("opacity", country === "Taiwan" ? 1 : 0.7);
            
            // Store label data for collision detection
            const lastPoint = sortedValues[sortedValues.length - 1];
            labelData.push({
                country: country,
                x: xScale(lastPoint.year) + 5,
                y: yScale(lastPoint.score),
                color: colorScale(country),
                fontSize: country === "Taiwan" ? 11 : 9,
                fontWeight: country === "Taiwan" ? "bold" : "normal"
            });
        });
        
        // Sort labels by y-position to process from top to bottom
        labelData.sort((a, b) => a.y - b.y);
        
        // Collision detection and adjustment
        const minLabelSpacing = 12; // Minimum vertical spacing between labels
        const adjustedLabels = [];
        
        labelData.forEach((label, i) => {
            let adjustedY = label.y;
            
            // Check for collisions with previous labels
            for (let j = 0; j < adjustedLabels.length; j++) {
                const prevLabel = adjustedLabels[j];
                const distance = Math.abs(adjustedY - prevLabel.y);
                
                if (distance < minLabelSpacing) {
                    // If too close, move this label down
                    adjustedY = prevLabel.y + minLabelSpacing;
                }
            }
            
            adjustedLabels.push({
                ...label,
                y: adjustedY
            });
        });
        
        // Draw labels with adjusted positions
        adjustedLabels.forEach(label => {
            g.append("text")
                .attr("x", label.x)
                .attr("y", label.y)
                .attr("dy", "0.35em")
                .attr("fill", label.color)
                .style("font-size", label.fontSize + "px")
                .style("font-weight", label.fontWeight)
                .text(label.country);
        });
        
        // Add X axis
        const xAxis = d3.axisBottom(xScale)
            .tickFormat(d3.format("d"))
            .ticks(10);
        
        const xAxisGroup = g.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(xAxis);
        
        // Rotate year labels 45 degrees
        xAxisGroup.selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-0.5em")
            .attr("dy", "0.5em")
            .attr("transform", "rotate(-45)");
        
        // Add axis label
        xAxisGroup.append("text")
            .attr("x", width / 2)
            .attr("y", 35)
            .attr("fill", "black")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Year");
        
        // Add Y axis (inverted)
        const yAxis = d3.axisLeft(yScale)
            .ticks(8);
        
        g.append("g")
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -40)
            .attr("x", -height / 2)
            .attr("fill", "black")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Score");
        
        // Add label at bottom (y=height position) showing max value - moved lower
        g.append("text")
            .attr("x", width + 5)
            .attr("y", height + 15) // Moved lower to avoid covering country names
            .attr("fill", "black")
            .style("text-anchor", "start")
            .style("font-size", "10px")
            .style("font-weight", "bold")
            .text(maxScore.toFixed(3));
        
        // Add label at top (y=0 position) showing min value - moved higher
        g.append("text")
            .attr("x", width + 5)
            .attr("y", -5) // Moved higher to avoid covering country names
            .attr("dy", "0.35em")
            .attr("fill", "black")
            .style("text-anchor", "start")
            .style("font-size", "10px")
            .style("font-weight", "bold")
            .text(minScore.toFixed(3));
    }
    
    // Initialize line chart when page loads
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', createLineChart);
    } else {
        createLineChart();
    }
    
    // Create military activities line chart
    function createMilitaryChart() {
        console.log("Creating military chart...");
        d3.csv("output_filtered.csv").then(function(data) {
            console.log("CSV data loaded:", data.length, "rows");
            console.log("First few rows:", data.slice(0, 3));
            
            // Parse and filter data
            const parsedData = data
                .filter(d => {
                    // Filter out rows with N/A or zero total sorties
                    const hasNA = d["Aircraft Sorties"] && d["Aircraft Sorties"].includes("N/A");
                    const totalIsZero = d["Total Sorties"] === "0" || d["Total Sorties"] === "";
                    return !hasNA && !totalIsZero;
                })
                .map(d => {
                    const dateStr = d["Date"];
                    const date = new Date(dateStr);
                    const aircraft = d["Aircraft Sorties"] && !d["Aircraft Sorties"].includes("N/A") ? +d["Aircraft Sorties"] : 0;
                    const vessel = d["Vessel Sorties"] && !d["Vessel Sorties"].includes("N/A") ? +d["Vessel Sorties"] : 0;
                    const total = +d["Total Sorties"] || 0;
                    
                    return {
                        date: date,
                        aircraft: aircraft,
                        vessel: vessel,
                        total: total
                    };
                })
                .filter(d => !isNaN(d.date.getTime())) // Filter out invalid dates
                .sort((a, b) => a.date - b.date); // Sort by date, oldest first
            
            console.log("Parsed data:", parsedData.length, "rows");
            console.log("Sample parsed data:", parsedData.slice(0, 3));
            
            if (parsedData.length === 0) {
                console.error("No valid data found after parsing");
                const chartContainer = d3.select(".military-chart");
                chartContainer.append("p")
                    .style("color", "red")
                    .text("No valid data found");
                return;
            }
            
            // Chart dimensions - make it larger and more balanced
            const margin = { top: 30, right: 60, bottom: 70, left: 60 };
            const containerWidth = 500; // Larger width for better balance
            const containerHeight = 400; // Larger height
            const width = containerWidth - margin.left - margin.right;
            const height = containerHeight - margin.top - margin.bottom;
            
            // Clear existing chart
            const chartContainer = d3.select(".military-chart");
            chartContainer.selectAll("*").remove();
            
            // Create SVG
            const svg = chartContainer.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // X scale (dates) - oldest to newest
            const dateExtent = d3.extent(parsedData, d => d.date);
            const xScale = d3.scaleTime()
                .domain([dateExtent[0], dateExtent[1]]) // Explicitly set oldest to newest
                .range([0, width]);
            
            // Y scale (sorties count) - shared scale for all three metrics
            const maxSorties = d3.max(parsedData, d => Math.max(d.aircraft, d.vessel, d.total));
            const yScale = d3.scaleLinear()
                .domain([0, maxSorties * 1.1]) // Add 10% padding at top
                .range([height, 0]);
            
            // Line generators
            const line = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.value))
                .curve(d3.curveMonotoneX);
            
            // Prepare data for each line
            const aircraftData = parsedData.map(d => ({ date: d.date, value: d.aircraft }));
            const vesselData = parsedData.map(d => ({ date: d.date, value: d.vessel }));
            const totalData = parsedData.map(d => ({ date: d.date, value: d.total }));
            
            // Color scale
            const colors = {
                aircraft: "#3b9797",
                vessel: "#16476a",
                total: "#bf092f"
            };
            
            // Draw lines
            g.append("path")
                .datum(aircraftData)
                .attr("fill", "none")
                .attr("stroke", colors.aircraft)
                .attr("stroke-width", 2)
                .attr("d", line);
            
            g.append("path")
                .datum(vesselData)
                .attr("fill", "none")
                .attr("stroke", colors.vessel)
                .attr("stroke-width", 2)
                .attr("d", line);
            
            g.append("path")
                .datum(totalData)
                .attr("fill", "none")
                .attr("stroke", colors.total)
                .attr("stroke-width", 2.5)
                .attr("d", line);
            
            // Add X axis (dates, oldest to newest)
            const xAxis = d3.axisBottom(xScale)
                .ticks(8)
                .tickFormat(d3.timeFormat("%m/%d"));
            
            const xAxisGroup = g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis);
            
            xAxisGroup.selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-0.5em")
                .attr("dy", "0.5em")
                .attr("transform", "rotate(-45)");
            
            // Add X axis label
            xAxisGroup.append("text")
                .attr("x", width / 2)
                .attr("y", 50)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .style("font-size", "12px")
                .text("Date");
            
            // Add Y axis (shared scale for Aircraft, Vessel, and Total Sorties)
            const yAxis = d3.axisLeft(yScale)
                .ticks(6);
            
            const yAxisGroup = g.append("g")
                .call(yAxis);
            
            // Add Y axis label
            yAxisGroup.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -40)
                .attr("x", -height / 2)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .style("font-size", "12px")
                .text("Number of Sorties");
            
            // Add legend
            const legend = g.append("g")
                .attr("transform", `translate(${width - 120}, 10)`);
            
            const legendData = [
                { label: "Aircraft", color: colors.aircraft },
                { label: "Vessel", color: colors.vessel },
                { label: "Total", color: colors.total }
            ];
            
            legendData.forEach((item, i) => {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`);
                
                legendRow.append("line")
                    .attr("x1", 0)
                    .attr("x2", 20)
                    .attr("y1", 0)
                    .attr("y2", 0)
                    .attr("stroke", item.color)
                    .attr("stroke-width", item.label === "Total" ? 2.5 : 2);
                
                legendRow.append("text")
                    .attr("x", 25)
                    .attr("y", 0)
                    .attr("dy", "0.35em")
                    .style("font-size", "11px")
                    .text(item.label);
            });
        }).catch(function(error) {
            console.error("Error loading military data:", error);
            const chartContainer = d3.select(".military-chart");
            chartContainer.append("p")
                .style("color", "red")
                .text("Error loading data: " + error.message);
        });
    }
    
    // Initialize military chart when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', createMilitaryChart);
    } else {
        createMilitaryChart();
    }
    
    const svg = d3.select("#treemap-svg");
    
    // Initialize Leaflet map (free, no API key needed!)
    function initMap() {
        console.log('=== INIT MAP CALLED ===');
        console.log('Leaflet available:', typeof L !== 'undefined');
        console.log('Map element:', document.getElementById('map'));
        
        try {
            // Check if Leaflet is loaded
            if (typeof L === 'undefined') {
                console.error('Leaflet library not loaded. Retrying in 200ms...');
                setTimeout(initMap, 200);
                return;
            }
            
            const mapElement = document.getElementById('map');
            if (!mapElement) {
                console.error('Map element not found!');
                return;
            }
            
            // Check if map element has dimensions
            const rect = mapElement.getBoundingClientRect();
            console.log('Map element dimensions:', rect.width, 'x', rect.height);
            console.log('Map element styles:', window.getComputedStyle(mapElement).height);
            
            // Center on Taiwan
            const taiwanCenter = [23.5, 121.0];
            
            // Initialize Leaflet map with OpenStreetMap tiles (free!)
            console.log('Creating Leaflet map...');
            map = L.map('map', {
                center: taiwanCenter,
                zoom: 7,
                zoomControl: true
            });
            
            console.log('Map created, adding tile layer...');
            
            // Add CartoDB Positron tile layer (cleaner, no administrative boundaries)
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors Â© <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
            
            console.log('Tile layer added. Map should be visible now!');
            
            // Load and add cables GeoJSON layer
            fetch('cables.geojson')
                .then(response => response.json())
                .then(cablesData => {
                    console.log('Cables GeoJSON loaded:', cablesData);
                    
                    // Add cables as a GeoJSON layer
                    const cablesLayer = L.geoJSON(cablesData, {
                        style: function(feature) {
                            return {
                                color: '#ff6b6b', // Red color for cables
                                weight: 2,
                                opacity: 0.8
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            // Add popup with cable information if available
                            if (feature.properties) {
                                const props = feature.properties;
                                let popupContent = '<div style="font-size: 12px;">';
                                if (props.name) popupContent += `<strong>${props.name}</strong><br>`;
                                if (props.owner) popupContent += `Owner: ${props.owner}<br>`;
                                if (props.length) popupContent += `Length: ${props.length}<br>`;
                                popupContent += '</div>';
                                layer.bindPopup(popupContent);
                            }
                            
                            // Add explosion emoji markers at specific locations for each LineString
                            if (feature.geometry && feature.geometry.type === 'LineString') {
                                // Get the index of this feature to determine which marker to use
                                const featureIndex = cablesData.features.indexOf(feature);
                                
                                // Define specific coordinates for each LineString
                                const markerCoords = [
                                    [23.252662957372274, 119.86820017108545], // First LineString
                                    [25.49412292011354, 121.54273753122117]  // Second LineString
                                ];
                                
                                // Add explosion emoji at the specified location
                                if (markerCoords[featureIndex]) {
                                    const markerNumber = 2 - featureIndex; // 2 for first, 1 for second
                                    const marker = L.marker(markerCoords[featureIndex], {
                                        icon: L.divIcon({
                                            className: 'explosion-marker',
                                            html: `<div style="text-align: center; line-height: 1;"><span style="font-size: 24px;">ðŸ’¥</span><br><span style="font-size: 14px; font-weight: bold; color: #000; background: rgba(255,255,255,0.8); padding: 2px 4px; border-radius: 3px;">${markerNumber}</span></div>`,
                                            iconSize: [40, 50],
                                            iconAnchor: [20, 25]
                                        })
                                    }).addTo(map);
                                    
                                    console.log('Added explosion marker', markerNumber, 'at:', markerCoords[featureIndex]);
                                }
                            }
                        }
                    }).addTo(map);
                    
                    console.log('Cables layer added to map');
                })
                .catch(error => {
                    console.error('Error loading cables.geojson:', error);
                });
            
            // Force map to invalidate size in case of layout issues
            setTimeout(function() {
                console.log('Invalidating map size...');
                map.invalidateSize();
            }, 200);
            
            // Load GeoJSON and draw treemap after map is ready
            map.whenReady(function() {
                console.log('Map is ready, checking for GeoJSON data...');
                console.log('geojsonData available:', !!geojsonData);
                
                if (geojsonData) {
                    console.log('Drawing treemap with existing GeoJSON data...');
                    drawTreemap(geojsonData);
                } else {
                    console.log('GeoJSON not loaded yet, will draw when it loads');
                }
            });
            
            // Redraw treemap on zoom and pan
            map.on('moveend', function() {
                if (geojsonData) {
                    drawTreemap(geojsonData);
                }
            });
            
            map.on('zoomend', function() {
                if (geojsonData) {
                    drawTreemap(geojsonData);
                }
            });
        } catch (error) {
            console.error('Error initializing map:', error);
            console.error('Error stack:', error.stack);
            const mapElement = document.getElementById('map');
            if (mapElement) {
                mapElement.innerHTML = '<div style="padding: 20px; text-align: center; color: red; background: white; z-index: 1000;">Error: ' + error.message + '<br>Check console for details.</div>';
            }
        }
    }
    
    // Wait for DOM and scripts to be ready
    function startInit() {
        console.log('=== STARTING INITIALIZATION ===');
        console.log('Document ready state:', document.readyState);
        console.log('Leaflet loaded:', typeof L !== 'undefined');
        console.log('Map div exists:', !!document.getElementById('map'));
        
        if (typeof L === 'undefined') {
            console.log('Leaflet not loaded yet, waiting...');
            setTimeout(startInit, 100);
            return;
        }
        
        if (!document.getElementById('map')) {
            console.log('Map div not found yet, waiting...');
            setTimeout(startInit, 100);
            return;
        }
        
        initMap();
    }
    
    // Start initialization
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startInit);
    } else {
        // DOM already loaded, but wait a bit for scripts
        setTimeout(startInit, 100);
    }
    
    // --- 1. Define Color Scales ---
    const colorRed = d3.scaleLinear()
        .domain([-3.845, -2.612]) // Min and Max negative scores
        .range(["#000000", "#1d81a2"]); // Deep Red to Light Red
    
    const colorGreen = d3.scaleLinear()
        .domain([2.402, 2.859]) // Min and Max positive scores
        .range(["#398564", "#fdfff5"]); // Light Green to Bright Green
    
    const getColor = (d) => {
        if (d.data.Category === 'Red') {
            return colorRed(d.data.Score);
        } else {
            return colorGreen(d.data.Score);
        }
    };
    
    // Find darkest blocks for text color determination
    const redScores = data.filter(d => d.Category === 'Red').map(d => d.Score);
    const greenScores = data.filter(d => d.Category === 'Green').map(d => d.Score);
    const darkestRed = Math.min(...redScores); // Most negative (darkest)
    const darkestGreen = Math.max(...greenScores); // Most positive (darkest)
    
    const getTextColor = (d) => {
        if (d.data.Category === 'Red') {
            return 'white'; // Darkest red block
        }  else {
            return 'black'; // All other blocks
        }
    };
    
    // Function to project lat/lng to pixel coordinates using Leaflet projection
    function projectLatLngToPixel(lat, lng) {
        if (!map) return null;
        
        // Leaflet's latLngToContainerPoint converts lat/lng to pixel coordinates
        const point = map.latLngToContainerPoint([lat, lng]);
        
        return [point.x, point.y];
    }
    
    // Function to draw/redraw the treemap
    function drawTreemap(geojson) {
        console.log('=== DRAWING TREEMAP ===');
        console.log('SVG element:', svg.node());
        console.log('SVG current content children:', svg.node() ? svg.node().children.length : 'no node');
        
        // Clear existing content (but keep test circle for now)
        const beforeClear = svg.node() ? svg.node().children.length : 0;
        console.log('SVG children before clear:', beforeClear);
        svg.selectAll("g, path, defs").remove();
        const afterClear = svg.node() ? svg.node().children.length : 0;
        console.log('SVG children after clear:', afterClear);
        
        // Get current dimensions
        const containerRect = document.getElementById("treemap-container").getBoundingClientRect();
        const width = containerRect.width;
        const height = containerRect.height;
        
        console.log('Container dimensions:', width, 'x', height);
        
        // Set SVG dimensions
        svg.attr("width", width).attr("height", height);
        
        if (!geojson || !geojson.features || geojson.features.length === 0) {
            console.error("Failed to load or parse taiwan.geojson, or it's empty.");
            return;
        }
        
        if (!map) {
            console.log("Map not ready yet, will retry...");
            return;
        }
        
        console.log('GeoJSON features:', geojson.features.length);
    
        // Assuming the GeoJSON contains one main feature for Taiwan
        const taiwanFeature = geojson.features[0];
    
        // Project coordinates using Leaflet projection
        function projectCoordinates(coords) {
            if (Array.isArray(coords[0])) {
                return coords.map(projectCoordinates);
            }
            // coords is [lng, lat] in GeoJSON format
            const pixel = projectLatLngToPixel(coords[1], coords[0]);
            return pixel || [0, 0];
        }
        
        // Get the geometry and project it
        const geometry = taiwanFeature.geometry;
        let outerRing;
        
        if (geometry.type === 'Polygon') {
            outerRing = geometry.coordinates[0];
        } else if (geometry.type === 'MultiPolygon') {
            outerRing = geometry.coordinates[0][0]; // First polygon, outer ring
        } else {
            console.error('Unsupported geometry type:', geometry.type);
            return;
        }
        
        const projectedPoints = outerRing.map(coord => projectCoordinates(coord));
        
        console.log('Projected points sample (first 3):', projectedPoints.slice(0, 3));
        
        // Filter out invalid points (points that are null or [0, 0])
        const validPoints = projectedPoints.filter(p => p && (p[0] !== 0 || p[1] !== 0));
        
        console.log('Valid points:', validPoints.length, 'out of', projectedPoints.length);
        
        if (validPoints.length === 0) {
            console.error("No valid projected points");
            return;
        }
        
        // Close the path if needed
        if (validPoints.length > 0 && 
            (validPoints[0][0] !== validPoints[validPoints.length - 1][0] ||
             validPoints[0][1] !== validPoints[validPoints.length - 1][1])) {
            validPoints.push(validPoints[0]);
        }
        
        // Create path data for Taiwan outline
        const taiwanPathData = "M" + validPoints.map(p => `${p[0]},${p[1]}`).join("L") + "Z";
        
        console.log('Taiwan path created, length:', taiwanPathData.length);
    
        // Define a clip path for the Taiwan shape
        console.log('Creating clip path...');
        const defs = svg.append("defs");
        const clipPath = defs.append("clipPath")
            .attr("id", "taiwan-clip");
        clipPath.append("path")
            .attr("d", taiwanPathData);
        console.log('Clip path created');
    
        // Taiwan outline removed - the map already shows Taiwan's boundaries
    
        // --- 3. Prepare Data for Voronoi Treemap ---
        const root = d3.hierarchy({ children: data })
            .sum(d => d.Size)
            .sort((a, b) => b.value - a.value);
    
        // --- 4. Initialize the Voronoi Treemap Layout ---
        if (typeof d3.voronoiTreemap === 'undefined') {
            console.error('d3-voronoi-treemap library not loaded!');
            return;
        }
    
        const voronoiTreemap = d3.voronoiTreemap()
            .clip(validPoints.slice(0, -1)); // Remove the closing point for clipping
    
        try {
            console.log('Computing voronoi treemap...');
            voronoiTreemap(root);
            console.log('Voronoi treemap computed successfully');
        } catch (error) {
            console.error('Error computing treemap:', error);
            console.error('Error stack:', error.stack);
            return;
        }
    
        // --- 6. Drawing the Cells (Polygons) ---
        console.log('Creating cells group...');
        const cellsGroup = svg.append("g")
            .attr("clip-path", "url(#taiwan-clip)");
        console.log('Cells group created:', cellsGroup.node());
    
        const leaves = root.leaves();
        console.log('Number of leaves (cells) to draw:', leaves.length);
        console.log('Sample leaf data:', leaves[0] ? {
            country: leaves[0].data.Country,
            hasPolygon: !!leaves[0].polygon,
            polygonLength: leaves[0].polygon ? leaves[0].polygon.length : 0
        } : 'no leaves');
        
        const cell = cellsGroup.selectAll(".cell")
            .data(leaves)
            .enter().append("g")
            .attr("class", "cell");
        
        console.log('Cell groups created:', cell.size());
    
        // Create tooltip element
        const tooltip = d3.select("#tooltip");
        
        console.log('Appending paths to cells...');
        const paths = cell.append("path")
            .attr("d", d => {
                if (!d.polygon || d.polygon.length === 0) {
                    console.warn('Cell has no polygon:', d.data.Country);
                    return null;
                }
                const pathData = "M" + d.polygon.map(p => `${p[0]},${p[1]}`).join("L") + "Z";
                return pathData;
            })
            .attr("fill", d => getColor(d))
            .on("mouseover", function(event, d) {
                // Show tooltip
                tooltip.select(".tooltip-title")
                    .text(d.data.Country);
                
                // Get rank (handle both "Rank" and "rank" cases)
                const rank = d.data.Rank || d.data.rank;
                
                tooltip.select(".tooltip-content")
                    .html(`Rank: ${rank}<br>` +
                          `Score: ${d.data.Score.toFixed(3)}<br>` +
                          `Category: ${d.data.Category}<br>` +
                          `Size: ${d.data.Size.toFixed(3)}`);
                
                tooltip.classed("visible", true);
            })
            .on("mouseout", function() {
                // Hide tooltip
                tooltip.classed("visible", false);
            })
            .on("mousemove", function(event) {
                // Follow mouse cursor
                const containerRect = document.getElementById("treemap-container").getBoundingClientRect();
                const tooltipNode = tooltip.node();
                const tooltipWidth = tooltipNode.offsetWidth || 150;
                const tooltipHeight = tooltipNode.offsetHeight || 80;
                
                // Position tooltip near cursor, offset to avoid covering the cursor
                let left = event.pageX - containerRect.left + 15;
                let top = event.pageY - containerRect.top - tooltipHeight - 10;
                
                // Keep tooltip within container bounds
                if (left + tooltipWidth > containerRect.width) {
                    left = event.pageX - containerRect.left - tooltipWidth - 15;
                }
                if (top < 0) {
                    top = event.pageY - containerRect.top + 15;
                }
                
                tooltip
                    .style("left", `${left}px`)
                    .style("top", `${top}px`);
            });
        
        console.log('Cells drawn:', cell.size());
    
        // --- 7. Add Labels (UPDATED LOGIC) ---
        cell.append("text")
            .attr("class", d => {
                // Add special class for Taiwan
                return d.data.Country === 'Taiwan' ? "country-label taiwan-label" : "country-label";
            })
            .attr("transform", d => `translate(${d3.polygonCentroid(d.polygon)})`) // Position at centroid
            .style("fill", d => getTextColor(d)) // Set text color based on block darkness
            .style("stroke", "none") // Explicitly remove stroke/outline
            .selectAll("tspan")
            .data(d => {
                // Data array to hold both the Country Name and the Score
                const labels = [];
                
                // 1. Country Name (can be shortened for small cells)
                const name = d.data.Country;
                const isTaiwan = name === 'Taiwan';
                if (!isTaiwan && d.value / root.value < 0.05) { // Heuristic: If cell is very small, use abbreviation
                    labels.push(name.substring(0, 3) + '.');
                } else {
                    labels.push(name);
                }
                
                // 2. Score Value
                labels.push(d.data.Score.toFixed(3)); 
                
                return labels;
            })
            .enter().append("tspan")
            .attr("x", 0) // Centered
            .attr("dy", (d, i) => { 
                 // First line (Country Name) is slightly above center
                 if (i === 0) return "-0.5em";
                 // Second line (Score Value) is on the baseline
                 return "1.2em"; 
            })
            .style("font-size", function(d, i) {
                // Check if parent text has taiwan-label class
                const isTaiwan = d3.select(this.parentNode).classed("taiwan-label");
                if (isTaiwan) {
                    return i === 1 ? "12px" : "14px"; // Larger font for Taiwan
                }
                return i === 1 ? "7px" : "8px"; // Normal size for others
            })
            .style("font-weight", (d, i) => i === 1 ? "normal" : "bold") // Country name bold
            .text(d => d);
    
        // Taiwan outline removed
    }
    
    // --- 2. Load Taiwan GeoJSON and draw treemap ---
    let geojsonData = null;
    d3.json("taiwan.geojson").then(function(geojson) {
        console.log('GeoJSON loaded successfully');
        console.log('GeoJSON features:', geojson.features ? geojson.features.length : 'none');
        geojsonData = geojson;
        // Draw treemap if map is already initialized
        if (map) {
            console.log('Map is ready, drawing treemap...');
            // Small delay to ensure map is fully rendered
            setTimeout(function() {
                drawTreemap(geojson);
            }, 300);
        } else {
            console.log('Map not ready yet, treemap will be drawn when map loads');
        }
    }).catch(function(error) {
        console.error("Error loading GeoJSON or creating treemap:", error);
        console.error("Error details:", error);
    });
    
    // Handle window resize with debouncing
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            if (geojsonData && map) {
                drawTreemap(geojsonData);
            }
        }, 250); // Wait 250ms after resize stops
    });
    
    // Make info boxes draggable
    function makeDraggable(element) {
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;
        
        const container = document.getElementById("treemap-container");
        const header = element.querySelector('h3');
        
        header.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        
        function dragStart(e) {
            if (e.button !== 0) return; // Only left mouse button
            
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
            
            if (e.target === header || header.contains(e.target)) {
                isDragging = true;
                element.classList.add('dragging');
                
                // Get current position
                const rect = element.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                xOffset = rect.left - containerRect.left;
                yOffset = rect.top - containerRect.top;
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
        }
        
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                
                xOffset = currentX;
                yOffset = currentY;
                
                // Get container bounds
                const containerRect = container.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                // Constrain to container bounds
                const minX = 0;
                const minY = 0;
                const maxX = containerRect.width - elementRect.width;
                const maxY = containerRect.height - elementRect.height;
                
                xOffset = Math.max(minX, Math.min(maxX, xOffset));
                yOffset = Math.max(minY, Math.min(maxY, yOffset));
                
                // Remove right/bottom positioning and use left/top
                element.style.right = 'auto';
                element.style.bottom = 'auto';
                element.style.left = xOffset + 'px';
                element.style.top = yOffset + 'px';
            }
        }
        
        function dragEnd(e) {
            if (isDragging) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
                element.classList.remove('dragging');
            }
        }
    }
    
    // Make info boxes resizable
    function makeResizable(element) {
        const resizeHandle = element.querySelector('.resize-handle');
        if (!resizeHandle) return;
        
        let isResizing = false;
        let startX, startY, startWidth, startHeight;
        
        resizeHandle.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            isResizing = true;
            element.classList.add('resizing');
            
            const rect = element.getBoundingClientRect();
            startX = e.clientX;
            startY = e.clientY;
            startWidth = rect.width;
            startHeight = rect.height;
            
            document.addEventListener('mousemove', handleResize);
            document.addEventListener('mouseup', stopResize);
        });
        
        function handleResize(e) {
            if (!isResizing) return;
            
            const container = document.getElementById("treemap-container");
            const containerRect = container.getBoundingClientRect();
            
            // Calculate new dimensions
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            let newWidth = startWidth + deltaX;
            let newHeight = startHeight + deltaY;
            
            // Get current position
            const currentLeft = parseInt(window.getComputedStyle(element).left) || 0;
            const currentTop = parseInt(window.getComputedStyle(element).top) || 0;
            
            // Constrain to container bounds and minimum size
            const minWidth = 200;
            const minHeight = 150;
            const maxWidth = containerRect.width - currentLeft;
            const maxHeight = containerRect.height - currentTop;
            
            newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
            newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
            
            // Apply new dimensions
            element.style.width = newWidth + 'px';
            element.style.height = newHeight + 'px';
        }
        
        function stopResize() {
            if (isResizing) {
                isResizing = false;
                element.classList.remove('resizing');
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            }
        }
    }
    
    // Initialize dragging and resizing for floating info boxes only (not section boxes)
    function initDraggableBoxes() {
        const infoBoxes = document.querySelectorAll('#treemap-container .info-box');
        infoBoxes.forEach(box => {
            makeDraggable(box);
            makeResizable(box);
        });
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDraggableBoxes);
    } else {
        initDraggableBoxes();
    }
    
    // Image Modal Functions
    function openImageModal(imageSrc) {
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');
        modal.classList.add('active');
        modalImg.src = imageSrc;
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
    }
    
    function closeImageModal() {
        const modal = document.getElementById('imageModal');
        modal.classList.remove('active');
        document.body.style.overflow = 'auto'; // Restore scrolling
    }
    
    // Close modal on Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            closeImageModal();
        }
    });
    
    </script>
    
    <!-- Image Modal -->
    <div id="imageModal" class="image-modal" onclick="closeImageModal()">
        <span class="image-modal-close" onclick="event.stopPropagation(); closeImageModal();">&times;</span>
        <img id="modalImage" class="image-modal-content" src="" alt="Enlarged image" onclick="event.stopPropagation();">
    </div>
</body>
</html>